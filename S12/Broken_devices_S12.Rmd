---
title: 'Project : Broken devices S12'
author: "Solène PETITO"
output:
  html_document: default
  pdf_document: default
  word_document: default
date: "2024-08-26"
editor_options: 
  markdown: 
    wrap: 72
---

# **SEMAINE DU 26 AOÛT 2024 au 30 AOÛT 2024 :**

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Cette commande permet de se mettre directement dans le dossier du fichier 
getwd()
```

```{r include=FALSE}
############### MODULE 1 : Chargement des librairies

library(openxlsx)
library(readxl)
library(ggplot2)
library(stringr)
library(tibble)
library(dplyr)
library(plotly) # permet de faire des graphes intéractifs
library(corrplot) # permet de réqliser des matrices de corrélation
library(tidyr)
library(RColorBrewer) # librairie pour les palettes de couleurs
library(viridis) # palette de couleurs > 25 nuances
library(Polychrome)
library(gridExtra) # afficher les graphes côte à côte
library(grid)

```

```{r include=FALSE}
############### MODULE 2 : Création de fonctions

##########################################

# Création d'une fonction **Count_VCM** (VCM = Variable à choix multiples) permettant d'afficher pour les variables à choix multiples UNIQUEMENT, le nombre de fois où chaque modalité est renseignée dans toute la colonne. Elle prend en entrée une variable à choix multiple (*variable*), issue de la base de données, et son nombre total de modalités (*nb_de_modalites*), et renvoit une matrice indiquant en ligne 1 le numéro de la modalité, et en ligne 2 le nombre de fois où les répondants l'on choisit.

Count_VCM <- function(variable,nb_de_modalites){
  mat <- matrix(0,nrow=2,ncol=nb_de_modalites)
  mat[1,]=c(1:nb_de_modalites)
  for (i in 1:length(variable)){
    ligne=str_extract_all(variable[i],".{2}")[[1]]
    vec=sub("^0+","",ligne)
    for (j in 1:length(vec)){
      for (k in 1:ncol(mat)){
        if (vec[j]==mat[1,k]){
          mat[2,k]=mat[2,k]+ 1 # mettre "+1" à la place de "data[i,"poids"]" si on ne concidère pas les poids
        }
      }
    }
  }
  return(mat)
}

##########################################

# Pour éviter d'avoir à afficher les numéros des modalités sur chaques graphes, je stocke directement les libellés des modalités dans des vecteurs

label_RIDENTIFICATION_PROBLEME = c("Problème avec l’écran","Problème de sensibilité du tactile","Problème avec l’appareil photo","Problème avec la lampe torche ou le flash","Problème avec le GPS","Problème avec le micro","Problème de son","Problème de prise jack","Problème de chargement","Problème de batterie","Problème de Wi-Fi","Problème de capteurs","Problème de Bluetooth ou de transferts de fichiers sans fil","Problème de téléphonie","Problème d’accès à Internet","Problème avec les boutons","Problème de vibreur","Stockage saturé","Système d’exploitation non mis à jour","Applications ne pouvant pas être téléchargées ou mises à jour","Problème lié à une fonctionnalité manquante","Fonctionnalité qui ne marche plus","Dysfonctionnement logiciel","Problèmes avec des applications","Problème de lenteur","Autre")

label_ACQUISITION = c("Quelqu’un me l’a offert ou donné","Quelqu’un me l’a prêté","Je l’ai acheté","Je l’ai obtenu dans le cadre de mon contrat avec mon opérateur","Mon employeur me l’a fourni","Je l’ai loué","Je ne me souviens pas","Obtenu par un autre moyen")

label_COHABITATION = c("Dès que j’ai décelé le dysfonctionnement","Moins d’un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de deux ans","Je ne sais pas" )

label_GENE=c("Très gênant","Plutôt gênant","Plutôt pas gênant","Pas gênant du tout")

label_INT_REPARATION= c("Oui, par moi-même","Oui, par le SAV ou un réparateur","Oui, par une connaissance","Pas pour l’instant", "Non")

label_RECENCE <- c("Dès la première utilisation","En moins de 3 mois","Entre 3 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Plus de 3 ans","Je ne sais pas")

label_REPARATION <- c("Oui et le problème est resolu","Oui mais le problème na pas pu être résolu","Non, le problème s’est résolu tout seul au bout d’un moment","Non, peut être plus tard","Non, je ne pense pas tenter de résoudre le problème")

label_OS <- c("IOS (Apple)","Android","Autre","Je ne sais pas")

label_ETAT= c("Neuf","D'occasion","Reconditionné","Je ne sais pas" )

label_COHAB_2 <- c("Moins d'un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de 2 ans")

label_RAISON_UTIL_PB <- c("Cela serait trop coûteux de résoudre le(s) problème(s) ou de remplacer mon smartphone",
"J’attends une opportunité", "Je ne peux pas résoudre le problème car le smartphone ne m’appartient pas","Je ne sais pas comment résoudre le(s) problème(s)","Je veux faire durer mon téléphone le plus longtemps possible","Ce(s) problème(s) ne m’impacte(nt) pas tant que ça au quotidien","Je n’ai pas pris le temps de m’en occuper, de chercher une solution","Mon téléphone est trop récent pour que je le fasse réparer ou que je le remplace","La résolution du (ou des) problème(s) est trop difficile ou incertaine","Ça me donne un prétexte pour moins l’utiliser","Cela ne vaut pas la peine de résoudre le(s) problème(s)","Mon smartphone a une particularité difficile à retrouver si je devais le remplacer","Autre")

label_IMPACT <- c("Usage global du smartphone","Communication ","Réseaux sociaux ","Cartes et guidage GPS","Jeux","Navigation web","Streaming musique et vidéo","Outils de productivité ","Logiciels et applications professionnelles dédiées","Photo, vidéo et autres activités de création","Identification bancaire, paiement sans contact","Tickets dématérialisés ","Courses et achats en ligne","Autre","Aucun")

label_dys <- c("Stockage","Matériel","Mise à jour","Dys divers")
```

```{r include=FALSE}
# Catégorisation des dysfonctionnements

label_dys <- c("Stockage","Matériel","Mise à jour","Dys divers")

materiel <- c(1,2,3,4,6,7,8,9,10,12,16,17)
dys_divers <- c(5,11,13,14,15,21,22,23,24,25)
stockage <- c(18)
maj <- c(19,20)

# Trouver la liste qui contient le plus d'éléments pour après définir le nombre de colonnes de notre matrice
max_length <- max(length(materiel), length(dys_divers), length(stockage), length(maj))

# Initialiser la matrice avec des zéros
matrice_cat <- matrix(0, nrow = 4, ncol = max_length)

# Remplir les lignes de la matrice avec les listes
matrice_cat[1, 1:length(stockage)] <- stockage
matrice_cat[2, 1:length(materiel)] <- materiel
matrice_cat[3, 1:length(maj)] <- maj
matrice_cat[4, 1:length(dys_divers)] <- dys_divers

# Afficher la matrice
print(matrice_cat)
```

**OBJECTIF :** *Analyser la base de données*

## **ANALYSE DE LA BASE DE DONNÉES**

```{r include=FALSE}
# Import des données

########## Pour la commande qui suit indiquer le chemin où se trouve le dossier data
setwd("/home/solene_petito/Bureau/Stage/Broken_devices")

data <- readRDS("data/data1.rds") # base de données sur laquelle on va appliquer tous les changements

# Exporter la base de données en format Excel
write.xlsx(data, file = "data/database.xlsx")

Broken_Devices_Data <- read.csv("data/Broken-Devices-Data1-xlsx.csv",row.names=1) # base de données initiale sur laquelle on pourra se référer pour voir si les chgts ont bien été appliqués

# nombre d'observations
nb_obs <- nrow(data) # 968 

# nombre de variables 
nb_var <- ncol(data) # 164
```


```{r include=FALSE}
REPARATION <- c(1:5)
matrice_REP=matrix(0,nrow=2,ncol=length(REPARATION))
matrice_REP[1,]=REPARATION

colonne_deb <- which(names(data) == "REPARATION_A1")
#print(colonne_deb) # 81

colonne_fin <- which(names(data) == "REPARATION_A25")
#print(colonne_fin) # 105

df <- data[,colonne_deb:colonne_fin]

for (i in 1 :ncol(df)){
    for (j in 1:nrow(df)){
      val=df[j,i]
      if(!is.na(val)&& !is.null(val)){
        matrice_REP[2,val]=matrice_REP[2,val]+1
      }
    }
}
```

### **I ) Temps de cohabitation de ceux qui ont tenté de résoudre le ou les dysfonctionnements rencontrés mais qui n'ont pas réussi**

```{r include=FALSE}
# Initialisation des vecteurs pour stocker les valeurs de recence, année, et mois
recence <- c()
annee <- c()
mois <- c()
poids = c()
rep =c()

# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105 (indices des colonnes réparation)
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle vaut 1 ou 2 ou 4 ou 5
    if (!is.na(val) && (val ==1 || val==2 || val==4 || val==5)) {
      RECENCE <- df[j, i - 25]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(RECENCE)) {
        rep = c(rep,val)
        recence <- c(recence, RECENCE)
        annee <- c(annee, df[j, "DATEOBTENTIONSMART_1"])
        mois <- c(mois, df[j, "DATEOBTENTIONSMART_2"])
        poids = c(poids,df[j,"poids"])
      }
    }
  }
}

# Suppression de la raison 7 dans la liste recence 

indices_rec_7= which(recence==7)
recence=recence[-c(indices_rec_7)]
annee=annee[-c(indices_rec_7)]
mois=mois[-c(indices_rec_7)]
poids = poids[-c(indices_rec_7)]
rep = rep[-c(indices_rec_7)]

# # Suppression de la raison 1 dans la liste reparation 

indices_rep_1= which(rep==1)
recence=recence[-c(indices_rep_1)]
annee=annee[-c(indices_rep_1)]
mois=mois[-c(indices_rep_1)]
poids = poids[-c(indices_rep_1)]

# Afficher les résultats pour vérifier
print(head(recence))
print(head(annee))
print(head(mois))

print(length(mois))
```

```{r include=FALSE}
# Changement du mois non renseigné indiqué par la valeur 99, par un mois "moyen" d'obtention pour l'année en question :

indices_mois_99 <- which(mois==99)
for (i in 1:length(indices_mois_99)){
  indice=indices_mois_99[i]
  year=annee[i]
  indices_annees = which(annee==year)
  liste_mois=mois[indices_annees]
  liste_mois=liste_mois[liste_mois!=99]
  mois[indice]=round(mean(liste_mois))
}
print(head(mois))
```

```{r include=FALSE}
# Création des dates avec l'année et le mois renseignés dans les listes annee et mois précédemment :

dates = c()
for (i in 1:length(recence)){
  date_str <- paste(annee[i], sprintf("%02d", mois[i]), "01", sep = "-")
  dates=c(dates,date_str)
}

head(dates)
```

```{r include=FALSE}
# On détermine une plage de valeurs en terme de dates durant laquelle les dysfonctionnements ont été décelés :

liste=c(0,list(c(1,83)),list(c(84,365)),list(c(366,730)),list(c(731,1095)),1096)
l=c()
for (i in 1:length(dates)){
  b=c()
  d=dates[i]
  r=recence[i]
  periode=liste[[r]]
  for (j in 1:length(periode)){
    a=as.Date(d)+periode[j]
    b[j]=a
    
  }
  l[i]=list(b)
}

date_ref <- as.Date("1970-01-01")

# Fonction pour convertir les jours en dates
convert_to_dates <- function(jours, date_ref) {
  return(as.Date(jours, origin = date_ref))
}

# Appliquer la conversion à chaque sous-liste
dates_list <- lapply(l, convert_to_dates)

# Afficher les dates exactes
print(head(dates_list))
```

```{r include=FALSE}
# Calcul du nombre de jours qui se sont écoulés entre ces plages de dates et novembre 2023 : 

# Date de référence
date_ref <- as.Date("2023-11-01")

# Fonction pour calculer les jours écoulés
calculate_days <- function(dates, reference_date) {
  return(as.numeric(dates - reference_date))
}

# Appliquer la fonction de calcul à chaque sous-liste
days_elapsed <- lapply(dates_list, calculate_days, reference_date = date_ref)

# Afficher les résultats
print(head(days_elapsed))

```

```{r include=FALSE}
# Calcul du temps de cohabitation : 

vec=c()
for(i in 1:length(days_elapsed)){
  days=days_elapsed[[i]]
  val=abs(sum(days))
  if(val %in% 0:30){
    vec[i]=1
  }
  if(val %in% 31:168){
    vec[i]=2
  }
  if(val %in% 169:730){
    vec[i]=3
  }
  if(val > 730){
    vec[i]=4
  }
}

vec
table(vec)

label_COHAB_2 <- c("Moins d'un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de 2 ans")
```
Pour déterminer le temps de cohabitation avec les dysfonctionnements des individus n'ayant pas résolu pas le problème, il a fallu prendre le mois et l'année d'obtention de leur téléphone, puis pour chaque dysfonctionnement rencontré, le temps approximatif durant lequel il se rendu compte du problème, et déterminer le temps qui séparait ce temps approximatif du mois de novembre 2023 (date du questionnaire). Voici les temps de cohabitation pour les personnes n'ayant pas résolu les problèmes : 

```{r echo=FALSE}
don2 <- as.matrix(tapply(poids, vec, sum))
Categorie <- factor(label_COHAB_2, levels = label_COHAB_2)

don <- data.frame(Categorie=Categorie, valeurs=round(don2[,1]*100/sum(don2[,1])))

p <- ggplot(don, aes(x = Categorie, y =valeurs )) +
  geom_bar(stat='identity',fill="turquoise4") +
  theme_minimal() +
  labs(title = "Répartition du temps de cohabitation",
       x = "Temps de cohabitation",
       y = "Pourcentage de dysfonctionnments (%)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="turquoise4"),
        axis.title.x = element_text(face = "bold",colour="turquoise4"),
        axis.title.y = element_text(face = "bold",colour="turquoise4"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

### **II ) Temps de cohabitation et catégorie de dysfonctionnement en fonction du degrès de gêne**
```{r include=FALSE}
### Création d'un dataframe avec 4 colonnes : le numéro du dys, la catégorie du dys, le degre de gêne du dys et le temps de cohabitation du dys :

# dys qui ont été résolus

pbs = c()
cate_dys = c()
deg_gene = c()
cohab = c()
poids1 =c()

df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27" & data$RIDENTIFICATION_PROBLEMES != "26"),]
variable = df$RIDENTIFICATION_PROBLEMES

for (i in 1:length(variable)){
  liste_pbs =str_extract_all(variable[i], ".{2}")[[1]]
  liste_pbs = as.numeric(liste_pbs)
  for (j in 1:length(liste_pbs)){
    pb = liste_pbs[j]
    num=as.character(pb)
    g=paste0("GENE_PROBLEMES_A",num)
    gene=df[i,g]
    c= paste0("COHABITATION_DYSFONCTION_A",num)
    coha = df[i,c]
    r = paste0("REPARATION_A",num)
    repa = df[i,r]
    if(!is.null(gene) && !is.na(gene) && !is.null(coha) && !is.na(coha) && !is.null(repa) && !is.na(repa) && repa==1){
      
      result <- which(matrice_cat == pb, arr.ind = TRUE)
      cat <- result[1]
      pbs = c(pbs,pb)
      cate_dys = c(cate_dys,cat)
      deg_gene = c(deg_gene,gene)
      cohab = c(cohab,coha)
      poids1 = c(poids1,df[i,"poids"])
        }
  }
}

#print(head(pbs))
#print(head(cate_dys))
#print(head(deg_gene))
#print((head(cohab)))

print(length(pbs))
print(length(cate_dys))
print(length(deg_gene))
print(length(cohab))



don = data.frame()
don <- data.frame( "Categorie_dys"=cate_dys, "Gêne"=deg_gene,"Cohab"=cohab, Poids=poids1)
don[which(don$Cohab==1),"Cohab"]=2 # On lie les "moins d'un mois" et les "dès que j'ai décelé le dys" ensemble
print(head(don))
print(nrow(don)) 
```

```{r include=FALSE}
# on ajoute +1 au temps de cohabitation des personnes n'ayant pas resolu pour qu'il puisse dans les memes valeurs que les personnes ayant résolu

COHAB_non_resolus <- vec + 1
COHAB_non_resolus

nb_non_resolus <- length(COHAB_non_resolus) # 316

vec
```

```{r include=FALSE}
# Caclul de la moyenne du temps de cohabitation tout type de réparation confondus en tenant compte des poids

v = c(don$Cohab,COHAB_non_resolus)
p =c(don$Poids,poids)

moyenne_ponderee <- sum(v * p) / sum(p)

# Afficher le résultat
print(label_COHABITATION[round(moyenne_ponderee)])
```

```{r include=FALSE}
# Tableaux de valeurs SANS poondération
res = table(v)
res

df = data.frame(Cohabitation = label_COHABITATION[2:6],Nb_dys=as.numeric(res),Pourcent = round(as.numeric(res)*100/sum(res),2))

total_row <- data.frame(
  Cohabitation = "Total",
  Nb_dys = sum(df$Nb_dys),
  Pourcent = sum(df$Pourcent)
)
df <- rbind(df, total_row)

df

# Tableaux de valeurs AVEC poondération
res = tapply(p,v,sum)
res

df = data.frame(Cohabitation = label_COHABITATION[2:6],Nb_dys=round(as.numeric(res)),Pourcent = round(as.numeric(res)*100/sum(res),2))

total_row <- data.frame(
  Cohabitation = "Total",
  Nb_dys = sum(df$Nb_dys),
  Pourcent = sum(df$Pourcent)
)
df <- rbind(df, total_row)

df
```



```{r include=FALSE}
# dys qui  n'ont pas été résolus

# Initialisation des vecteurs pour stocker les valeurs de recence, année, et mois
recence <- c()
annee <- c()
mois <- c()
gene <- c()
pbs = c()
cate_dys = c()
poids2 = c()


# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105 (indice des colonnes reparation)
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val==2 || val == 4 || val == 5)) {
      RECENCE <- df[j, i - 25]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(RECENCE)) {
        recence <- c(recence, RECENCE)
        annee <- c(annee, df[j, "DATEOBTENTIONSMART_1"])
        mois <- c(mois, df[j, "DATEOBTENTIONSMART_2"])
        gene <- c(gene,df[j, i - 50])
        result <- which(matrice_cat == (i-80), arr.ind = TRUE)
        cat <- result[1]
        pbs = c(pbs,i-80)
        cate_dys = c(cate_dys,cat)
        poids2 = c(poids2,df[i,"poids"])
      }
    }
  }
}

# Suppression de la raison 7 dans la liste recence 

indices_rec_7= which(recence==7)
gene=gene[-c(indices_rec_7)]
pbs=pbs[-c(indices_rec_7)]
cate_dys=cate_dys[-c(indices_rec_7)]
poids2 = poids2[-c(indices_rec_7)]

don2 <- data.frame( "Categorie_dys"=cate_dys, "Gêne"=gene,"Cohab"=COHAB_non_resolus, Poids = poids2)

# Afficher les résultats pour vérifier
print(head(pbs))
print(head(cate_dys))
print(head(gene))

# Jointure des dataframe entre eux 
don <- rbind(don,don2)

# Création d'un autre dataframe pour une future jointure 
don1 <- rbind(don,don2)

head(don)
nrow(don)
nrow(don2)
```

```{r include=FALSE}
# calcul du nombre de personnes pour les différents cas possibles

liste = c()
for (k in 1:nrow(don)){
  i = don[k,"Gêne"]
  j = don[k,"Categorie_dys"]
  l = don[k,"Cohab"]
  df2 <- don[which(don$Categorie_dys==j & don$Gêne==i & don$Cohab==l),]
  #nb = nrow(df2)
  nb = sum(df2$Poids)
  liste = c(liste,nb)
  
}
don$nb <- round(liste)
don = don[,c("Cohab","Categorie_dys","Gêne","nb")]
don <- unique(don)
don <- don %>% 
  arrange( Cohab,Categorie_dys,Gêne)

lab<- c("Dys Stockage trés gênant","Dys Stockage plutôt gênant","Dys Stockage plutôt pas gênant","Dys Matériel trés gênant","Dys Matériel plutôt gênant","Dys Matériel plutôt pas gênant","Dys Maj trés gênant","Dys Maj plutôt gênant","Dys Maj plutôt pas gênant", "Dys divers trés gênant","Dys divers plutôt gênant","Dys divers plutôt pas gênant")

df <- data.frame(
  Colonne1 = lab[1:3],
  Colonne2 = lab[4:6],
  Colonne3 = lab[7:9],
  Colonne4 = lab[10:12]
)

label=c()
for(i in 1:nrow(don)){
  gene = don[i,"Gêne"]
  cat = don[i,"Categorie_dys"]
  label=c(label,df[gene,cat])
}

don$label= label

print(don)
nrow(don)
```


```{r include=FALSE}
# moins d'un mois
moins_1_mois <- don[don$Cohab==2,]
matrice = matrix(0,nrow=3,ncol=4)

for ( i in 1:ncol(matrice)){
  for (j in 1:nrow(matrice)){
    matrice[j,i]=moins_1_mois[which(moins_1_mois$Gêne==j & moins_1_mois$Categorie_dys==i),"nb"]
  }
}
matrice

normalize3 <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat3 <- t(apply(matrice,1, normalize3))
print(normalized_mat3)

Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[1,], GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*normalized_mat3[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$abs_valeurs <- abs(df_combined$valeurs)

df_combined$GÊNE <- factor(df_combined$GÊNE, levels = c("Très gênant", "Plutôt gênant", "Plutôt pas gênant"))

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack", width = 1, color = "white") +
  labs(title = " ",
       x = "Cohabitation : Moins d'un mois ",
       y = "Frequency (Malfunctions) ") +
  theme_minimal() +
  scale_fill_manual(values = c("Très gênant" = "red3", "Plutôt gênant" = "darkorange2", "Plutôt pas gênant" = "palegreen3")) +
  coord_flip() +
  scale_y_continuous(labels = function(x) abs(x), breaks = seq(-50, 100, by = 25), limits = c(-50, 100)) +  # Fixer les limites ici
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text(face = "bold"),
        axis.title.y = element_text(size = 20,face = "bold", colour = "red3"),
        legend.position = "none") 

p_interactif <- ggplotly(p)


df_T1 <- data.frame(Categorie = Categorie, valeurs = (matrice[1,]), GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*matrice[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$GÊNE = factor(df_combined$GÊNE,levels=label_GENE)

# Créer un diagramme en barres empilées
p1 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 1,color = "white") +
  labs(title = " ",
       x = " ",
       y = "Count (Malfunctions) ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold"),legend.position="none") + scale_y_continuous(labels = function(x) abs(x), breaks = seq(-2000, 5000, by = 1000),limits = c(-2000, 5000))

p1_interactif <- ggplotly(p1)

```


```{r echo=FALSE}
subplot(
  p_interactif, p1_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)),  # Déplacer le deuxième graphique vers la droite
    yaxis2 = list(showticklabels = FALSE))
```

```{r include=FALSE}
# 1 à 6 mois
un_et_6_mois <- don[don$Cohab==3,] 
un_et_6_mois$nb[is.na(un_et_6_mois$nb)] <- 0

# Initialiser la matrice avec des zéros
matrice <- matrix(0, nrow = max(un_et_6_mois$Gêne), ncol = max(un_et_6_mois$Categorie_dys))

# Remplir la matrice avec des valeurs du dataframe 'un_et_6_mois'
for (i in 1:ncol(matrice)) {
  for (j in 1:nrow(matrice)) {
    val <- un_et_6_mois[which(un_et_6_mois$Gêne == j & un_et_6_mois$Categorie_dys == i), "nb"]
    if (length(val) > 0 && !is.na(val)) {
      matrice[j, i] <- val
    }
  }
}

normalize3 <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat3 <- t(apply(matrice,1, normalize3))
print(normalized_mat3)

Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[1,], GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*normalized_mat3[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$abs_valeurs <- abs(df_combined$valeurs)

df_combined$GÊNE <- factor(df_combined$GÊNE, levels = c("Très gênant", "Plutôt gênant", "Plutôt pas gênant"))

# Créer un diagramme en barres empilées
p2 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 1,color = "white") +
  labs(title = " ",
       x = "Cohabitation : Entre 1 mois et 6 mois",
       y = "Frequency (Malfunctions) ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  scale_y_continuous(labels = function(x) abs(x), breaks = seq(-50, 100, by = 25), limits = c(-50, 100))+ # 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(size = 20,face = "bold",colour="red3"),
        legend.position = "none") 

p2_interactif <- ggplotly(p2)

df_T1 <- data.frame(Categorie = Categorie, valeurs = (matrice[1,]), GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*matrice[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$GÊNE = factor(df_combined$GÊNE,levels=label_GENE)

# Créer un diagramme en barres empilées
p3 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 1,color = "white") +
  labs(title = " ",
       x = " ",
       y = "Count (Malfunctions) ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold"),legend.position="none")+ scale_y_continuous(labels = function(x) abs(x), breaks = seq(-2000, 5000, by = 1000), limits = c(-2000, 5000))

p3_interactif <- ggplotly(p3)
```


```{r echo=FALSE}
subplot(
  p2_interactif, p3_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)),  # Déplacer le deuxième graphique vers la droite
    yaxis2 = list(showticklabels = FALSE))
```

```{r include=FALSE}
############### 6 mois à 2 ans

six_mois_2ans <- don[don$Cohab==4,] 
six_mois_2ans$nb[is.na(six_mois_2ans$nb)] <- 0

# Initialiser la matrice avec des zéros
matrice <- matrix(0, nrow = max(six_mois_2ans$Gêne), ncol = max(six_mois_2ans$Categorie_dys))

for (i in 1:ncol(matrice)) {
  for (j in 1:nrow(matrice)) {
    val <- six_mois_2ans[which(six_mois_2ans$Gêne == j & six_mois_2ans$Categorie_dys == i), "nb"]
    if (length(val) > 0 && !is.na(val)) {
      matrice[j, i] <- val
    }
  }
}

normalize3 <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat3 <- t(apply(matrice,1, normalize3))
print(normalized_mat3)

Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[1,], GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*normalized_mat3[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$abs_valeurs <- abs(df_combined$valeurs)

df_combined$GÊNE <- factor(df_combined$GÊNE, levels = c("Très gênant", "Plutôt gênant", "Plutôt pas gênant"))

# Créer un diagramme en barres empilées
p4 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 1,color = "white") +
  labs(title = " ",
       x = "Cohabitation : Entre 6 mois et 2 ans",
       y = "Frequency (Malfunctions) ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  scale_y_continuous(labels = function(x) abs(x), breaks = seq(-50, 100, by = 25), limits = c(-50, 100)) + # 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(size = 20,face = "bold",colour="red3"),
        legend.position = "none") 

p4_interactif <- ggplotly(p4)

df_T1 <- data.frame(Categorie = Categorie, valeurs = (matrice[1,]), GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*matrice[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$GÊNE = factor(df_combined$GÊNE,levels=label_GENE)

# Créer un diagramme en barres empilées
p5 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 1,color = "white") +
  labs(title = " ",
       x = " ",
       y = "Count (Malfunctions) ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold"),legend.position="none") + scale_y_continuous(labels = function(x) abs(x), breaks = seq(-2000, 5000, by = 1000),limits = c(-2000, 5000))

p5_interactif <- ggplotly(p5)
```


```{r echo=FALSE}
subplot(
  p4_interactif, p5_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)),  # Déplacer le deuxième graphique vers la droite
    yaxis2 = list(showticklabels = FALSE))
```

```{r include=FALSE}
############### Plus de 2 ans

plus_de_2ans <- don[don$Cohab==5,] 
plus_de_2ans$nb[is.na(plus_de_2ans$nb)] <- 0

# Initialiser la matrice avec des zéros
matrice <- matrix(0, nrow = max(plus_de_2ans$Gêne), ncol = max(plus_de_2ans$Categorie_dys))

for (i in 1:ncol(matrice)) {
  for (j in 1:nrow(matrice)) {
    val <- plus_de_2ans[which(plus_de_2ans$Gêne == j & plus_de_2ans$Categorie_dys == i), "nb"]
    if (length(val) > 0 && !is.na(val)) {
      matrice[j, i] <- val
    }
  }
}

normalize3 <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat3 <- t(apply(matrice,1, normalize3))
print(normalized_mat3)

Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[1,], GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*normalized_mat3[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$abs_valeurs <- abs(df_combined$valeurs)

df_combined$GÊNE <- factor(df_combined$GÊNE, levels = c("Très gênant", "Plutôt gênant", "Plutôt pas gênant"))

# Créer un diagramme en barres empilées
p6 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 1,color = "white") +
  labs(title = "  ",
       x = " Cohabitation : Plus de 2 ans ",
       y = "Frequency (Malfunctions) ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +scale_y_continuous(labels = function(x) abs(x), breaks = seq(-50, 100, by = 25), limits = c(-50, 100)) + # 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(size = 20,face = "bold",colour="red3"),
        legend.position = "none") 

p6_interactif <- ggplotly(p6)

df_T1 <- data.frame(Categorie = Categorie, valeurs = (matrice[1,]), GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*matrice[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$GÊNE = factor(df_combined$GÊNE,levels=label_GENE)

# Créer un diagramme en barres empilées
p7 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 1,color = "white") +
  labs(title = " ",
       x = " ",
       y = "Count (Malfunctions) ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold"),legend.position="none")+ scale_y_continuous(labels = function(x) abs(x), breaks = seq(-2000, 5000, by = 1000),limits = c(-2000, 5000))

p7_interactif <- ggplotly(p7)
```


```{r echo=FALSE}
subplot(
  p6_interactif, p7_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)),  # Déplacer le deuxième graphique vers la droite
    yaxis2 = list(showticklabels = FALSE))
```

```{r include=FALSE}
############### Je ne sais pas

jsp <- don[don$Cohab==6,] 
jsp$nb[is.na(jsp$nb)] <- 0

# Initialiser la matrice avec des zéros
matrice <- matrix(0, nrow = max(jsp$Gêne), ncol = max(jsp$Categorie_dys))

for (i in 1:ncol(matrice)) {
  for (j in 1:nrow(matrice)) {
    val <- jsp[which(jsp$Gêne == j & jsp$Categorie_dys == i), "nb"]
    if (length(val) > 0 && !is.na(val)) {
      matrice[j, i] <- val
    }
  }
}

normalize3 <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat3 <- t(apply(matrice,1, normalize3))
normalized_mat3[is.na(normalized_mat3)]==0

Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[1,], GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*normalized_mat3[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$abs_valeurs <- abs(df_combined$valeurs)

df_combined$GÊNE <- factor(df_combined$GÊNE, levels = c("Très gênant", "Plutôt gênant", "Plutôt pas gênant"))

# Créer un diagramme en barres empilées
p8 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 1,color = "white") +
  labs(title = " ",
       x = "Cohabitation : Je ne sais pas",
       y = "Frequency (Malfunctions) ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +scale_y_continuous(labels = function(x) abs(x), breaks = seq(-50, 100, by = 25), limits = c(-50, 100)) + # 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(size = 20,face = "bold",colour="red3"),
        legend.position = "none") 

p8_interactif <- ggplotly(p8)

df_T1 <- data.frame(Categorie = Categorie, valeurs = (matrice[1,]), GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*matrice[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$GÊNE = factor(df_combined$GÊNE,levels=label_GENE)

# Créer un diagramme en barres empilées
p9 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 1,color = "white") +
  labs(title = " ",
       x = " ",
       y = "Count (Malfunctions) ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold"),legend.position="none") + scale_y_continuous(labels = function(x) abs(x), breaks = seq(-2000, 5000, by = 1000) ,limits = c(-2000, 5000))

p9_interactif <- ggplotly(p9)
```


```{r include=FALSE}
# Tableaux de valeurs 

df <- df_combined %>% arrange(Categorie,desc(GÊNE))

df$valeurs=abs(df$valeurs)

matrice

normalized_mat3

round(colSums(matrice)*100/sum(colSums(matrice)))

colSums(matrice)
```

```{r echo=FALSE}
subplot(
  p8_interactif, p9_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)),  # Déplacer le deuxième graphique vers la droite
    yaxis2 = list(showticklabels = FALSE))
```

```{r include=FALSE}
# Exporter le graphe en SVG

# Charger les bibliothèques nécessaires
library(ggplot2)
library(cowplot)  # Ou library(patchwork)

# Combiner les graphiques côte à côte
combined_plot <- plot_grid(p,p1,p2,p3,p4,p5,p6,p7,p8,p9, ncol = 2,nrow=5, align = "v")

# Enregistrer en SVG
svg("TC.svg", width = 25, height = 28)
print(combined_plot)
dev.off()

```





```{r include=FALSE }
indice_colonne <- which(names(data) == "GENE_PROBLEMES_A1")
print(indice_colonne) # 106

indice_colonne <- which(names(data) == "REPARATION_A1")
print(indice_colonne) # 81

indice_colonne <- which(names(data) == "GENE_PROBLEMES_A25")
print(indice_colonne) # 80

indice_colonne <- which(names(data) == "REPARATION_A25")
print(indice_colonne) #105

81-31

```

