---
title: 'Project : Broken devices S4'
author: "Solène PETITO"
output:
  html_document: default
  pdf_document: default
  word_document: default
date: "2024-06-24"
editor_options: 
  markdown: 
    wrap: 72
---

# **SEMAINE DU 24 JUIN 2024 au 28 JUIN 2024 :**

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
############### MODULE 1 : Chargement des librairies

library(readxl)
library(ggplot2)
library(stringr)
library(tibble)
library(dplyr)
library(plotly) # permet de faire des graphes intéractifs
library(corrplot) # permet de réqliser des matrices de corrélation
library(tidyr)
library(RColorBrewer) # librairie pour les palettes de couleurs


```

```{r include=FALSE}
############### MODULE 2 : Création de fonctions

# fonction func1 qui prend en entrée un jeu de données (don) et le nom d'une colonne de type Cri (Caratère répétitive) de ce jeu de données (colonne), sous forme de chaine de caractères et sans préciser de numéro à la fin de celle-ci  : ex : "COHABITATION_DYSFONCTION_A" ou "GENE_PROBLEMES_A". Elle renvoit en sortie une matrice a 2 lignes et 25 colonnes, indiquant en ligne 1 le type de dysfonctionnement, et en ligne 2 une modalité moyenne calculée pour la variable donnée en entrée pour chaque type de dysfonctionnements.

func1 <- function (don,colonne){
  matrice <- matrix(0,nrow=2,ncol=25)
  matrice[1,] <- c(1:25)
  df = don[which(don$RIDENTIFICATION_PROBLEMES!="27"),]
  variable=df$RIDENTIFICATION_PROBLEMES
  for (pb in 1:25){
    vec=c()
    for (i in 1:length(variable)){
      ligne=str_extract_all(variable[i], ".{2}")[[1]]
      ligne=sub("^0+", "", ligne)
      if (pb %in% ligne){
        num=as.character(pb)
        nom_colonne=paste0(colonne,num)
        valeur=df[i,nom_colonne]
        if(!is.null(valeur) && !is.na(valeur)){
          vec=c(vec,valeur)
        }
      }
    }
    if (length(vec) > 0) {
    matrice[2, pb] <- round(mean(vec))
  } else {
    matrice[2, pb] <- 0
  }
  }
  return(matrice)
}
##########################################

# Création d'une fonction **Count_VCM** (VCM = Variable à choix multiples) permettant d'afficher pour les variables à choix multiples UNIQUEMENT, le nombre de fois où chaque modalité est renseignée dans toute la colonne. Elle prend en entrée une variable à choix multiple (*variable*), issue de la base de données, et son nombre total de modalités (*nb_de_modalites*), et renvoit une matrice indiquant en ligne 1 le numéro de la modalité, et en ligne 2 le nombre de fois où les répondants l'on choisit.

Count_VCM <- function(variable,nb_de_modalites){
  mat <- matrix(0,nrow=2,ncol=nb_de_modalites)
  mat[1,]=c(1:nb_de_modalites)
  for (i in 1:length(variable)){
    ligne=str_extract_all(variable[i],".{2}")[[1]]
    vec=sub("^0+","",ligne)
    for (j in 1:length(vec)){
      for (k in 1:ncol(mat)){
        if (vec[j]==mat[1,k]){
          mat[2,k]=mat[2,k]+1
        }
      }
    }
  }
  return(mat)
}

##########################################

# Pour éviter d'avoir à afficher les numéros des modalités sur chaques graphes, je stocke directement les libellés des modalités dans des vecteurs

label_RIDENTIFICATION_PROBLEME = c("Problème avec l’écran","Problème de sensibilité du tactile","Problème avec l’appareil photo","Problème avec la lampe torche ou le flash","Problème avec le GPS","Problème avec le micro","Problème de son","Problème de prise jack","Problème de chargement","Problème de batterie","Problème de Wi-Fi","Problème de capteurs","Problème de Bluetooth ou de transferts de fichiers sans fil","Problème de téléphonie","Problème d’accès à Internet","Problème avec les boutons","Problème de vibreur","Stockage saturé","Système d’exploitation non mis à jour","Applications ne pouvant pas être téléchargées ou mises à jour","Problème lié à une fonctionnalité manquante","Fonctionnalité qui ne marche plus","Dysfonctionnement logiciel","Problèmes avec des applications","Problème de lenteur","Autre")

label_ACQUISITION = c("Quelqu’un me l’a offert ou donné","Quelqu’un me l’a prêté","Je l’ai acheté","Je l’ai obtenu dans le cadre de mon contrat avec mon opérateur","Mon employeur me l’a fourni","Je l’ai loué","Je ne me souviens pas","Obtenu par un autre moyen")

label_COHABITATION = c("Dès que j’ai décelé le dysfonctionnement","Moins d’un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de deux ans","Je ne sais pas" )

label_GENE=c("Très gênant","Plutôt gênant","Plutôt pas gênant","Pas gênant du tout")

label_INT_REPARATION= c("Oui, par moi-même","Oui, par le SAV ou un réparateur","Oui, par une connaissance","Pas pour l’instant", "Non")

label_RECENCE <- c("Dès la première utilisation","En moins de 3 mois","Entre 3 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Plus de 3 ans","Je ne sais pas")

label_REPARATION <- c("Oui et le problème est resolu","Oui mais le problème na pas pu être résolu","Non, le problème s’est résolu tout seul au bout d’un moment","Non, peut être plus tard","Non, je ne pense pas tenter de résoudre le problème")

label_OS <- c("IOS (Apple)","Android","Autre","Je ne sais pas")

label_ETAT= c("Neuf","D'occasion","Reconditionné","Je ne sais pas" )

label_COHAB_2 <- c("Moins d'un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de 2 ans")

```

**OBJECTIF :** *Analyser la base de données*

## **ANALYSE DE LA BASE DE DONNÉES**

### **I ) Import de la nouvelle base de données formattée**

```{r}
# Import des données

data <- readRDS("/home/solene_petito/Bureau/Stage/Broken_devices/data/data1.rds") # base de données sur laquelle on va appliquer tous les changements

Broken_Devices_Data <- read.csv("/home/solene_petito/Bureau/Stage/Broken_devices/data/Broken-Devices-Data1-xlsx.csv",row.names=1) # base de données initiale sur laquelle on pourra se référer pour voir si les chgts ont bien été appliqués

# nombre d'observations
nb_obs <- nrow(data) # 968 

# nombre de variables 
nb_var <- ncol(data) # 164
```

```{r include=FALSE}
View(data)
View(Broken_Devices_Data)
```

### **II ) Systèmes d'exploitation et dysfonctionnements**

La question posée était : **Quel est le système d'exploitation de ce
smartphone ?**

Les réponses possibles étaient :

-   1 : IOS (Apple)
-   2 : Android
-   3 : Autre
-   4 : Je ne sais pas

Voici le pourcentage de réponses obtenues : 
```{r echo=FALSE}
nb_individus=nrow(data)
valeurs=as.matrix(table(data$OS))

Categorie <- factor(label_OS, levels = label_OS)

df <- data.frame(Categorie=Categorie,Valeurs=round(valeurs*100/nb_individus))

# Créer un diagramme en barres empilées
p <- ggplot(df, aes(x = Categorie, y = Valeurs)) +
  geom_bar(stat = "identity",fill="turquoise4") +
  labs(title = "Répartition des systèmes d'exploitation",
       x = "Système d'exploitation",
       y = "Pourcentage de personnes (en %) ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="turquoise4"),
        axis.title.x = element_text( face = "bold",colour="turquoise4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="turquoise4")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 


```

```{r echo=FALSE}
don <- tapply(data$poids, data$OS, sum)

df <- data.frame(OS =names(don), Nb_personnes = floor(as.numeric(don)), Pourcent= round(as.numeric(don)*100/sum(as.numeric(don)),1))
df <- df %>% 
  arrange( desc(Nb_personnes))

df$OS = factor(df$OS, labels=label_OS)

print(head(df))

#print(floor(sum(as.numeric(don)))) #47831
```


La plupart des propriétaires de smartphone ont donc des androids (67% des
personnes de la base).

Regardons maintenant le nombre de personnes rencontrant des
dysfonctionnements pour chaque système d'exploitation :

```{r echo=FALSE}
sys = sort(unique(data$OS))
mat = matrix(0,nrow=3,ncol=length(sys))
mat[1,]=sys

for (i in 1:length(sys)){
  df=data[which(data$OS==i),]
  nb_ind = round(sum(df$poids))
  df2 = data[which(data$OS==i & data$RIDENTIFICATION_PROBLEMES!="27"),]
  nb_ind_pb=round(sum(df2$poids))
  mat[2,i]=nb_ind
  mat[3,i]=nb_ind_pb
}

dataframe <- data.frame("Sytèmes d'exploitation"=label_OS,"Nb_personnes"=mat[2,],"Nb_personnes_dys"=mat[3,],"Pourcentage_dys"=round(mat[3,]*100/mat[2,]))

print(dataframe)

```

Le diagramme à barres suivant permet de visualiser cette répartition :

```{r echo=FALSE}
df_T1 <- data.frame(OS = Categorie, valeurs = dataframe$Nb_personnes_dys, Legende = "Dysfonctionnements")
df_T2 <- data.frame(OS = Categorie, valeurs =dataframe$Nb_personnes-dataframe$Nb_personnes_dys  , Legende = "Pas de dysfonctionnements")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = OS, y = valeurs, fill = Legende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" so on veut des barres côtes à côtes
  labs(title = "Problèmes rencontrés en fonction du système d'exploitation",
       x = "OS",
       y = "Nombre de personnes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

### **III ) Etat du smartphone**

#### **1 ) Combien de personnes ont acheté leur smartphone neuf ? Combien l'ont eu d'occasion ? Combien l'on acheté reconditionné ?** 

Le graphe suivant nous apporte plus de détails :

```{r echo=FALSE}
nb_individus=sum(data$poids)
valeurs=as.matrix(tapply(data$poids, data$ETATSMARTPHONE, sum)) 

Categorie <- factor(label_ETAT, levels = label_ETAT)

df <- data.frame(Categorie=Categorie,Valeurs=round(valeurs*100/nb_individus))

# Créer un diagramme en barres empilées
p <- ggplot(df, aes(x = Categorie, y = Valeurs)) +
  geom_bar(stat = "identity",fill="thistle4") +
  labs(title = "Etat du smartphone",
       x = "Etat",
       y = "Pourcentage de personnes (en %) ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="thistle4"),
        axis.title.x = element_text( face = "bold",colour="thistle4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="thistle4")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 

```

Parmis ces différents états quelle est la part de dysfonctionnements ?

```{r echo=FALSE}
etat = sort(unique(data$ETATSMARTPHONE))
mat = matrix(0,nrow=3,ncol=length(etat))
mat[1,]=sys

for (i in 1:length(etat)){
  df=data[which(data$ETATSMARTPHONE==i),]
  nb_ind = sum(df$poids)
  df2 = data[which(data$ETATSMARTPHONE==i & data$RIDENTIFICATION_PROBLEMES!="27"),]
  nb_ind_pb=sum(df2$poids)
  mat[2,i]=round(nb_ind)
  mat[3,i]=round(nb_ind_pb)
}

dataframe <- data.frame("État"=label_ETAT,"Nb_personnes"=mat[2,],"Nb_personnes_dys"=mat[3,],"Pourcentage_dys"=round(mat[3,]*100/mat[2,]))

print(dataframe)
```

La part de dysfonctionnements pour les smarthpones d'occasion est assez importante (50%), suivie des smartphones reconditionnés avec une part de 45% de dysfonctionnements.

#### **2 ) Smartphone d'occasion** 

Parmis les smartphones d'occasion, quelle était leur durée d'utilisation avant que le propriétaire l'obtienne, et quel impact cela a eu sur le fait que le propriétaire rencontre des dysfonctionnements ou pas ?

Le graphe suivant nous donne plus de détails : 

```{r echo=FALSE}
label_duree_occas <- c("Moins de 6 mois","Entre 6 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Entre 3 et 5 ans","Plus de 5 ans","Je ne sais pas")

df =data[which(data$ETATSMARTPHONE==2 & data$RIDENTIFICATION_PROBLEMES!="27"),c("UTILISATIONSMARTOCCAS","poids")]
total = sum(data[which(data$ETATSMARTPHONE==2 & data$RIDENTIFICATION_PROBLEMES!="27"),"poids"]) # 45 obs

don2 <- as.matrix(tapply(df$poids, df$UTILISATIONSMARTOCCAS, sum)) 
Categorie <- factor(label_duree_occas, levels = label_duree_occas)

don <- data.frame(Categorie=Categorie, valeurs=round(don2[,1]*100/total),2)

p <- ggplot(don, aes(x = Categorie, y =valeurs )) +
  geom_bar(stat='identity',fill="turquoise4") +
  theme_minimal() +
  labs(title = "Ancienne durée du smartphone et pbs actuels",
       x = "Ancienne durée du smartphone d'occasion",
       y = "Pourcentage de personnes (%)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="turquoise4"),
        axis.title.x = element_text(face = "bold",colour="turquoise4"),
        axis.title.y = element_text(face = "bold",colour="turquoise4"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 


```


```{r echo=FALSE}

label_duree_occas <- c("Moins de 6 mois","Entre 6 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Entre 3 et 5 ans","Plus de 5 ans","Je ne sais pas")

df =data[which(data$ETATSMARTPHONE==2 & data$RIDENTIFICATION_PROBLEMES!="27"),c("UTILISATIONSMARTOCCAS","poids")]
total = sum(data[which(data$ETATSMARTPHONE==2 & data$RIDENTIFICATION_PROBLEMES!="27"),"poids"]) # 45 obs

don2 <- as.matrix(tapply(df$poids, df$UTILISATIONSMARTOCCAS, sum)) 
Categorie <- factor(label_duree_occas, levels = label_duree_occas)

don <- data.frame(Ancienne_duree_smart_occas=Categorie, Nb_personnes_dys=round(don2[,1]) ,Pourcent=round(don2[,1]*100/total),2)
don

```


### **IV ) Groupement des thématiques par catégories**

Groupement plus fin par thématiques : 

Les différentes catégories pourraient être :

-   **Problèmes matériels :** Problème avec l'écran, Problème de
    sensibilité du tactile, Problème avec l'appareil photo, Problème
    avec la lampe torche ou le flash, Problème avec le micro, Problème
    de son, Problème de prise jack, Problème de chargement, Problème de
    batterie, Problème de capteurs, Problème avec les boutons, Problème
    de vibreur

-   **Problèmes de connectivité (ou de réseau) :** Problème avec le GPS,
    Problème de Wi-Fi, Problème de Bluetooth ou de transferts de
    fichiers sans fil, Problème de téléphonie, Problème d'accès à
    Internet

-   **Problèmes logiciels :** Système d'exploitation non mis à jour,
    Applications ne pouvant pas être téléchargées ou mises à jour,
    Fonctionnalité qui ne marche plus, Dysfonctionnement logiciel,
    Problèmes avec des applications

-   **Problèmes de performance :** Problème de lenteur, Stockage saturé

-   **Problèmes divers :** Problème lié à une fonctionnalité manquante,
    Autre

```{r include=FALSE}
label_dys <- c("Matériel","Logiciel","Réseau","Performance","Divers")

materiel <- c(1,2,1,3,4,6,7,8,9,10,11,12,16,17)
logiciel <- c(19,20,22,23,24)
reseau <- c(5,11,13,14,15)
performance <- c(18,25)
divers <- c(21,26)

# Trouver la liste qui contient le plus d'éléments pour après définir le nombre de colonnes de notre matrice
max_length <- max(length(materiel), length(logiciel), length(reseau), length(performance), length(divers))

# Initialiser la matrice avec des zéros
matrice_cat <- matrix(0, nrow = 5, ncol = max_length)

# Remplir les lignes de la matrice avec les listes
matrice_cat[1, 1:length(materiel)] <- materiel
matrice_cat[2, 1:length(logiciel)] <- logiciel
matrice_cat[3, 1:length(reseau)] <- reseau
matrice_cat[4, 1:length(performance)] <- performance
matrice_cat[5, 1:length(divers)] <- divers

# Afficher la matrice
print(matrice_cat)

```

##### **1 ) Visualisation des catégories** 

Le tableau suivant donne le nombre de dysfonctionnements rencontrés pour chaque catégorie, et la part de chaque catégorie par rapport au nombre total de dysfonctionnements qui est de 832 :

```{r echo=FALSE}
pbs= Count_VCM(data$RIDENTIFICATION_PROBLEMES,26)
nb_total_pbs <- sum(pbs[2,])

mat=matrix(0,nrow=2,ncol=length(label_dys))
mat[1,]=c(1:length(label_dys))

df = data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
variable = df$RIDENTIFICATION_PROBLEMES

for (i in 1:length(variable)){
  liste_pbs=str_extract_all(variable[i],".{2}")[[1]]
  liste_pbs=as.numeric(liste_pbs)
  for (j in liste_pbs){
    if (j %in% materiel){
      mat[2,1]=mat[2,1]+df[i,"poids"]    
      }
    if (j %in% logiciel){
      mat[2,2]=mat[2,2]+df[i,"poids"] 
    }
    if (j %in% reseau){
      mat[2,3]=mat[2,3]+df[i,"poids"] 
    }
    if (j %in% performance){
      mat[2,4]=mat[2,4]+df[i,"poids"] 
    }
    if (j %in% divers){
      mat[2,5]=mat[2,5]+df[i,"poids"] 
    }
  }
}

don <- data.frame("Dysfonctionnements"=label_dys,"Nb_dys"=round(mat[2,]),"Pourcentage_dys"=round(mat[2,]*100/nb_total_pbs))
print(don)

```

Le graphique à barres suivant permet de visualiser ces valeurs : 

```{r echo=FALSE}
# PROGRAMME


Categorie <- factor(label_dys, levels = label_dys)

df <- data.frame(Categorie=Categorie,Valeurs=round(mat[2,]*100/nb_total_pbs))

# Créer un diagramme en barres empilées
p <- ggplot(df, aes(x = Categorie, y = Valeurs)) +
  geom_bar(stat = "identity",fill="turquoise4") +
  labs(title = "Pourcentage de dysfonctionnements",
       x = "Dysfonctionnements",
       y = "Pourcentage de dysfonctionnements (en %) ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="turquoise4"),
        axis.title.x = element_text( face = "bold",colour="turquoise4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="turquoise4")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

##### **2 ) Types de gênes ressenties en fonction des catégories**

Parmis ces différentes catégories quels sont les types de gênes ressenties pour chacun des dysfonctionnements, le tableau suivant indique ces différents types de gênes ressenties pour chacunes des catégories en pourcentage : 

```{r echo=FALSE}
CATEGORIE <- c(1:5)

mat <- matrix(0,nrow=5,ncol=length(CATEGORIE))
mat[1,] <- CATEGORIE

df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
variable=df$RIDENTIFICATION_PROBLEMES

for (i in 1:ncol(mat)){
  liste_val=matrice_cat[i,]
  for (j in 1:length(variable)){
  liste_pbs=str_extract_all(variable[j],".{2}")[[1]]
  liste_pbs=as.numeric(liste_pbs)
  for (k in liste_pbs){
    if (k %in% liste_val){
      num=as.character(k)
      nom_colonne=paste0("GENE_PROBLEMES_A",num)
      valeur=df[j,nom_colonne]
      if(!is.null(valeur) && !is.na(valeur)){
        mat[valeur+1,i]=mat[valeur+1,i]+ df[i,"poids"]
        }
    }
  }
  }
  
}

df <- data.frame("Dysfonctionnements"=label_dys, "Nb_dys"=don$Nb_dys,"Trés gênant"=round(mat[2,]*100/don$Nb_dys),"Plutôt gênant"=round(mat[3,]*100/don$Nb_dys),"Plutôt pas gênant"=round(mat[4,]*100/don$Nb_dys),"Pas gênant du tout"=round(mat[5,]*100/don$Nb_dys))
print(df)

```

Le graphique à barres suivant permet de visualiser cette répartion : 

```{r echo=FALSE}
Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = round((mat[2,]*100/nb_total_pbs),2), Gêne = "Trés gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = round(mat[3,]*100/nb_total_pbs,2), Gêne = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = round(mat[4,]*100/nb_total_pbs,2), Gêne = "Plutôt pas gênant")
df_T4 <- data.frame(Categorie = Categorie, valeurs = round(mat[5,]*100/nb_total_pbs,2), Gêne = "Pas gênant du tout")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3, df_T4)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Gêne)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Type de gênes ressenties par catégorie",
       x = "Dysfonctionnements",
       y = "Pourcentage de dysfonctionnements ") +
  scale_fill_manual(values = c("Trés gênant" = "#1f77b4", 
                               "Plutôt gênant" = "#6baed6", 
                               "Plutôt pas gênant" = "#9ecae1", 
                               "Pas gênant du tout" = "#c6dbef")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="#1f77b4"),
        axis.title.x = element_text( face = "bold",colour="#1f77b4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="#1f77b4")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

La gêne ressentie parmis tous les dysfonctionnements et ce peut importe la catégorie, est en grande marjorité "plutôt gênante".



#### **3 ) Répartition des catégories pour chaque type de résolution**

```{r include=FALSE}
REPARATION = C(1:5)
mat = matrix(0,nrow=6,ncol=length(REPARATION))
mat[1,]=REPARATION
df = data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
variable=df$RIDENTIFICATION_PROBLEMES
for (i in 1:length(variable)){
  liste_pbs=liste_pbs=str_extract_all(variable[i],".{2}")[[1]]
  liste_pbs=as.numeric(liste_pbs)
  for (j in 1:length(liste_pbs)){
    pb=liste_pbs[j]
    num=as.character(pb)
    nom_colonne=paste0("REPARATION_A",num)
    val=df[i,nom_colonne]
    if (!is.na(val) && !is.null(val)){
      result <- which(matrice_cat == pb, arr.ind = TRUE)
      row_index <- result[1]
      mat[row_index+1,val]=mat[row_index+1,val]+1
    }

    
  }
}
print(mat)


```
Quelle est la part de résolution des dysfonctionnments entre ces catégories ? 

```{r echo=FALSE}
Categorie <- factor(label_REPARATION, levels = label_REPARATION)

df_T1 <- data.frame(Résolution = Categorie, valeurs = round((mat[2,]*100/nb_total_pbs),2), Dysfonctionnement = "Matériel")
df_T2 <- data.frame(Résolution = Categorie, valeurs = round(mat[3,]*100/nb_total_pbs,2), Dysfonctionnement = "Logiciel")
df_T3 <- data.frame(Résolution = Categorie, valeurs = round(mat[4,]*100/nb_total_pbs,2), Dysfonctionnement = "Réseau")
df_T4 <- data.frame(Résolution = Categorie, valeurs = round(mat[5,]*100/nb_total_pbs,2), Dysfonctionnement = "Performance")
df_T5 <- data.frame(Résolution = Categorie, valeurs = round(mat[6,]*100/nb_total_pbs,2), Dysfonctionnement = "Divers")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3, df_T4,df_T5)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Résolution, y = valeurs, fill = Dysfonctionnement)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Résolution du problème en fonction de la catégorie",
       x = "Types de résolution",
       y = "Pourcentage de dysfonctionnements") +
  
  scale_fill_brewer(palette = "Greens", name = "Dysfonctionnements") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="palegreen3"),
        axis.title.x = element_text( face = "bold",colour="palegreen3"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="palegreen3")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```
On remarque que dans chaque catégorie, les dysfonctionnements majoritaires sont ceux étant matériels, suivis de ceux étant liés à la performance. Les parts des différentes catégories semblent être assez égales entre chaque types de résolution.


Le tableau suivant donne plus de détails pour chaque types de résolution, avec une part en pourcentage pour cahque catégorie de dysfonctionnements, pour chaque type de résolution : 

```{r echo=FALSE}
REPARATION <- c(1:5)
matrice_REP=matrix(0,nrow=2,ncol=length(REPARATION))
matrice_REP[1,]=REPARATION

colonne_deb <- which(names(data) == "REPARATION_A1")
#print(colonne_deb) # 81

colonne_fin <- which(names(data) == "REPARATION_A25")
#print(colonne_fin) # 105

df <- data[,colonne_deb:colonne_fin]

for (i in 1 :ncol(df)){
    for (j in 1:nrow(df)){
      val=df[j,i]
      if(!is.na(val)&& !is.null(val)){
        matrice_REP[2,val]=matrice_REP[2,val]+1
      }
    }
}

df <- data.frame(Résolution=label_REPARATION,Dys_Materiel=round(mat[2,]*100/matrice_REP[2,]),Dys_Logiciel=round(mat[3,]*100/matrice_REP[2,]),Dys_Reseau=round(mat[4,]*100/matrice_REP[2,]),Dys_Performance=round(mat[5,]*100/matrice_REP[2,]),Dys_Divers=round(mat[6,]*100/matrice_REP[2,]))

print(df)
```

#### **4 ) Temps de cohabitation de ceux qui ont résolu le problème ou qui ont tenté de le résoudre en fonction des catégories de dysfonctionnements**

Voici la répartition des temps de cohabitation pour les dysfonctionnements qui ont été résolus ou qui ont tenté d'être résolus :
```{r include=FALSE}
COHABITATION = c(1:6)
mat = matrix(0,nrow=6,ncol=length(COHABITATION))
mat[1,]=COHABITATION
df = data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
variable=df$RIDENTIFICATION_PROBLEMES
for (i in 1:length(variable)){
  liste_pbs=liste_pbs=str_extract_all(variable[i],".{2}")[[1]]
  liste_pbs=as.numeric(liste_pbs)
  for (j in 1:length(liste_pbs)){
    pb=liste_pbs[j]
    num=as.character(pb)
    nom_colonne=paste0("COHABITATION_DYSFONCTION_A",num)
    val=df[i,nom_colonne]
    if (!is.na(val) && !is.null(val)){
      result <- which(matrice_cat == pb, arr.ind = TRUE)
      row_index <- result[1]
      mat[row_index+1,val]=mat[row_index+1,val]+1
    }

    
  }
}
print(mat)

```

```{r echo=FALSE}
total_pbs_resolus = sum(matrice_REP[2,1:2])
Categorie <- factor(label_COHABITATION, levels = label_COHABITATION)

df_T1 <- data.frame(Categorie = Categorie, valeurs = round((mat[2,]*100/total_pbs_resolus),2), Dysfonctionnement = "Matériel")
df_T2 <- data.frame(Categorie = Categorie, valeurs = round(mat[3,]*100/total_pbs_resolus,2), Dysfonctionnement = "Logiciel")
df_T3 <- data.frame(Categorie = Categorie, valeurs = round(mat[4,]*100/total_pbs_resolus,2), Dysfonctionnement = "Réseau")
df_T4 <- data.frame(Categorie = Categorie, valeurs = round(mat[5,]*100/total_pbs_resolus,2), Dysfonctionnement = "Performance")
df_T5 <- data.frame(Categorie = Categorie, valeurs = round(mat[6,]*100/total_pbs_resolus,2), Dysfonctionnement = "Divers")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3, df_T4,df_T5)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Dysfonctionnement)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Temps de cohabitation en fonction de la catégorie",
       x = "Temps de cohabitation",
       y = "Pourcentage de dysfonctionnements (%) ") +
  
  scale_fill_brewer(palette = "Purples", name = "Dysfonctionnements") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="purple4"),
        axis.title.x = element_text( face = "bold",colour="purple4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="purple4")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```
Ce graphe nous montre que les problèmes de type matériel sont ceux qui ce règlent le plus vite.

### **V ) Temps de cohabitation de ceux qui n'ont pas résolu le problème** 

```{r include=FALSE}
pbs= Count_VCM(data$RIDENTIFICATION_PROBLEMES,26)
nb_total_pbs <- sum(pbs[2,])
print(nb_total_pbs) #832
```

```{r include=FALSE}
# Initialisation des vecteurs pour stocker les valeurs de recence, année, et mois
recence <- c()
annee <- c()
mois <- c()
poids = c()

# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 4 || val == 5)) {
      RECENCE <- df[j, i - 25]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(RECENCE)) {
        recence <- c(recence, RECENCE)
        annee <- c(annee, df[j, "DATEOBTENTIONSMART_1"])
        mois <- c(mois, df[j, "DATEOBTENTIONSMART_2"])
        poids = c(poids,df[j,"poids"])
      }
    }
  }
}

# Suppression de la raison 7 dans la liste recence 

indices_rec_7= which(recence==7)
recence=recence[-c(indices_rec_7)]
annee=annee[-c(indices_rec_7)]
mois=mois[-c(indices_rec_7)]
poids = poids[-c(indices_rec_7)]

# Afficher les résultats pour vérifier
print(head(recence))
print(head(annee))
print(head(mois))
```

```{r include=FALSE}
# Changement du mois non renseigné indiqué par la valeur 99, par un mois "moyen" d'obtention pour l'année en question :

indices_mois_99 <- which(mois==99)
for (i in 1:length(indices_mois_99)){
  indice=indices_mois_99[i]
  year=annee[i]
  indices_annees = which(annee==year)
  liste_mois=mois[indices_annees]
  liste_mois=liste_mois[liste_mois!=99]
  mois[indice]=round(mean(liste_mois))
}
print(head(mois))
```

```{r include=FALSE}
# Création des dates avec l'année et le mois renseignés dans les listes annee et mois précédemment :

dates = c()
for (i in 1:length(recence)){
  date_str <- paste(annee[i], sprintf("%02d", mois[i]), "01", sep = "-")
  dates=c(dates,date_str)
}

head(dates)
```

```{r include=FALSE}
# On détermine une plage de valeurs en terme de dates durant laquelle les dysfonctionnements ont été décelés :

liste=c(0,list(c(1,83)),list(c(84,365)),list(c(366,730)),list(c(731,1095)),1096)
l=c()
for (i in 1:length(dates)){
  b=c()
  d=dates[i]
  r=recence[i]
  periode=liste[[r]]
  for (j in 1:length(periode)){
    a=as.Date(d)+periode[j]
    b[j]=a
    
  }
  l[i]=list(b)
}

date_ref <- as.Date("1970-01-01")

# Fonction pour convertir les jours en dates
convert_to_dates <- function(jours, date_ref) {
  return(as.Date(jours, origin = date_ref))
}

# Appliquer la conversion à chaque sous-liste
dates_list <- lapply(l, convert_to_dates)

# Afficher les dates exactes
print(head(dates_list))
```

```{r include=FALSE}
# Calcul du nombre de jours qui se sont écoulés entre ces plages de dates et novembre 2023 : 

# Date de référence
date_ref <- as.Date("2023-11-01")

# Fonction pour calculer les jours écoulés
calculate_days <- function(dates, reference_date) {
  return(as.numeric(dates - reference_date))
}

# Appliquer la fonction de calcul à chaque sous-liste
days_elapsed <- lapply(dates_list, calculate_days, reference_date = date_ref)

# Afficher les résultats
print(head(days_elapsed))

```

```{r include=FALSE}
# Calcul du temps de cohabitation : 

vec=c()
for(i in 1:length(days_elapsed)){
  days=days_elapsed[[i]]
  val=abs(sum(days))
  if(val %in% 0:30){
    vec[i]=1
  }
  if(val %in% 31:168){
    vec[i]=2
  }
  if(val %in% 169:730){
    vec[i]=3
  }
  if(val > 730){
    vec[i]=4
  }
}

vec
table(vec)

label_COHAB_2 <- c("Moins d'un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de 2 ans")
```
Pour déterminer le temps de cohabitation avec les dysfonctionnements des individus n'ayant pas résolu pas le problème, il a fallu prendre le mois et l'année d'obtention de leur téléphone, puis pour chaque dysfonctionnement rencontré, le temps approximatif durant lequel il se rendu compte du problème, et déterminer le temps qui séparait ce temps approximatif du mois de novembre 2023 (date du questionnaire). Voici les temps de cohabitation pour les personnes n'ayant pas résolu les problèmes : 

```{r echo=FALSE}
don2 <- as.matrix(tapply(poids, vec, sum))
Categorie <- factor(label_COHAB_2, levels = label_COHAB_2)

don <- data.frame(Categorie=Categorie, valeurs=round(don2[,1]*100/sum(don2[,1])))

p <- ggplot(don, aes(x = Categorie, y =valeurs )) +
  geom_bar(stat='identity',fill="turquoise4") +
  theme_minimal() +
  labs(title = "Répartition du temps de cohabitation",
       x = "Temps de cohabitation",
       y = "Pourcentage de dysfonctionnments (%)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="turquoise4"),
        axis.title.x = element_text(face = "bold",colour="turquoise4"),
        axis.title.y = element_text(face = "bold",colour="turquoise4"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

```{r}
df <- data.frame(Cohabitation = Categorie, Nb_dys =round(don2[,1]), Pourcent=round(don2[,1]*100/sum(don2[,1])))
df
```


Voici la même représentation mais avec la part de chaque catégorie de dysfonctionnements :

```{r include=FALSE}
cat = c()
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),81:105]

# Parcourir les colonnes de 81 à 105
for (i in 1:ncol(df)) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 4 || val == 5)) {
      result <- which(matrice_cat == i, arr.ind = TRUE)
      row_index <- result[1]
      cat=c(cat,row_index)
      
    }
  }
}
cat=cat[-c(indices_rec_7)]

```

```{r echo=FALSE}

COHAB <- factor(vec, levels = 1:length(label_COHAB_2),labels=label_COHAB_2)
DYS <- factor(cat, levels = 1:length(label_dys),labels=label_dys)

# Créer un data frame avec les facteurs
df <- data.frame(Dysfonctionnement = DYS, Cohabitation = COHAB)

# Créer un diagramme à barres empilées avec ggplot2
p <- ggplot(df, aes(x = Cohabitation, fill = Dysfonctionnement)) +
  geom_bar(position = "stack") +
  labs(title = "Temps de cohabitation en fonction des catégories",
       x = "Temps de cohabitation",
       y = "Nombre de dysfonctionnements",
       fill = "Dysfonctionnement") +
  scale_fill_manual(values = colorRampPalette(brewer.pal(9, "Spectral"))(length(levels(df$Dysfonctionnement)))) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text(face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold"))

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

```{r include=FALSE}
# AVEC POIDS 

COHAB <- factor(vec, levels = 1:length(label_COHAB_2),labels=label_COHAB_2)
DYS <- factor(cat, levels = 1:length(label_dys),labels=label_dys)

don<- data.frame(Dysfonctionnement = DYS, Cohabitation = COHAB, Poids = round(poids))
nb = c()

for (i in 1:nrow(don)){
   C = don[i,"Cohabitation"]
   D = don[i,"Dysfonctionnement"]
   d = don[don$Cohabitation==C & don$Dysfonctionnement==D,"Poids"]
   nb = c(nb,sum(d))
  }

don$nb_dys = nb 
don = don[,c("Dysfonctionnement", "Cohabitation","nb_dys")]
don=unique(don)

don <- don %>% 
  arrange( Dysfonctionnement,Cohabitation)

don


# SANS POIDS 

df<- data.frame(Dysfonctionnement = DYS, Cohabitation = COHAB)
nb = c()
for (i in 1:nrow(df)){
   C = df[i,"Cohabitation"]
   D = df[i,"Dysfonctionnement"]
   d = df[df$Cohabitation==C & df$Dysfonctionnement==D,]
   nb = c(nb,nrow(d))
  }

df$nb_dys = nb 
df = df[,c("Dysfonctionnement", "Cohabitation","nb_dys")]
df=unique(df)

df <- df %>% 
  arrange( Dysfonctionnement,Cohabitation)
df 



```






La grande part de problèmes avec lesquels les personnes cohabitent sont les problèmes matériels.

Voici une autre représentation mais sous forme de nuage de points, afin de mieux voir la répartition des valeurs : 

```{r echo=FALSE}
don <- data.frame(obs=c(1:length(vec)),Cohabitation = factor(vec, levels = sort(unique(vec)), labels = label_COHAB_2)) # Ajouter une colonne numérique Temps
p <- ggplot(don, aes(x = obs, y =Cohabitation )) +
  geom_point(col="orchid4") +
  theme_minimal() +
  labs(title = "Nuage de points du temps de cohabitation",
       y = "Temps de cohabitation",
       x = "Individus") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="orchid4"),
        axis.title.x = element_text(face = "bold",colour="orchid4"),
        axis.title.y = element_text(face = "bold",colour="orchid4"),
        axis.text.y = element_text(angle = 45, hjust = 1, vjust = 1)) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

On remarque que le temps de cohabitation avec le problème, lorsqu'on ne l'a pas résolu est de deux ans en trés grande marjorité, suivi de entre 6 mois et 2 ans.

### **VI ) Nombre de dysfonctionnements** 

#### **1 ) Nombre de dysfonctionnements rencontrés par année d'obtention** 

```{r include=FALSE}
annees <- c()
dys <- c()
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
date=df$DATEOBTENTIONSMART_1
pbs=df$RIDENTIFICATION_PROBLEMES
for(i in 1:length(date)){
  annees=c(annees,date[i])
  liste_pbs=str_extract_all(pbs[i], ".{2}")[[1]]
  dys=c(dys,length(liste_pbs))
}

dataframe <- data.frame(Obtention=annees,Nb_dysfonctionnements=dys)

Nb_personnes_concernees <- c()
for (i in 1:nrow(dataframe)){
  annee=dataframe[i,1]
  dysfonc=dataframe[i,2]
  don <- dataframe[which(dataframe$Obtention==annee & dataframe$Nb_dysfonctionnements==dysfonc),]
  Nb_personnes_concernees <- c(Nb_personnes_concernees,nrow(don))
}

df2 <- data.frame(Obtention=annees,Nb_dysfonctionnements=dys,Nb_personnes_concernees=Nb_personnes_concernees)

print(df2)
```

Il serait intéressant de savoir quel est le nombre de personnes ayant rencontré 1,2,3 ou plus de dysfonctionnements en fonction de l'année d'obtention de leur smartphone. On se concentre sur les 5 dernières années car c'est celles pour lesquelles le nombre de dysfonctionnements rencontrés est important. Le graphe suivant nous apporte plus de détails : 

```{r echo=FALSE}

df3 = df2[which(df2$Obtention > 2017),]
df3 = distinct(df3)

df3$Obtention = as.factor(df3$Obtention)
df3$Nb_dysfonctionnements = as.factor(df3$Nb_dysfonctionnements)

# Créer le diagramme à barres empilées
p <- ggplot(df3, aes(x = Obtention, y = Nb_personnes_concernees, fill =Nb_dysfonctionnements)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_brewer(palette = "Reds", name = "Nb de Dysfonctionnements") +
  labs(title = "Nombre de dysfonctionnements par année d'obtention",
       x = "Année d'obtention",
       y = "Nombre de personnes concernées") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="orangered3"),
        axis.title.x = element_text(face = "bold",colour="orangered3"),
        axis.title.y = element_text(face = "bold",colour="orangered3"))

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

On observe que de 2018 à 2020, le nombre de dysfonctionnements rencontrés par individus est de 2 en général, et que vers 2021 il passe à 1 majoritairement.

#### **2 ) Nombre de dysfonctionnements par temps de cohabitation (de ceux qui ont tenté de résoudre le pb ou qui l'ont résolu)**

Ce graphe présente le nombre de personnes ayant cohabité avec des problèmes, et le nombre de dysfonctionnements qu'ils rencontraients à ce moment là : 
```{r include=FALSE}
nb_dys = c()
cohab = c()


df = data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
variable=df$RIDENTIFICATION_PROBLEMES
for (i in 1:length(variable)){
  liste_pbs=liste_pbs=str_extract_all(variable[i],".{2}")[[1]]
  liste_pbs=as.numeric(liste_pbs)
  for (j in 1:length(liste_pbs)){
    pb=liste_pbs[j]
    num=as.character(pb)
    nom_colonne=paste0("COHABITATION_DYSFONCTION_A",num)
    val=df[i,nom_colonne]
    if (!is.na(val) && !is.null(val)){
      nb_dys=c(nb_dys,length(liste_pbs))
      cohab=c(cohab,val)
    }
  }
}

df5 <- data.frame(nb_dys=nb_dys,cohab=cohab)
print(df5)
data1 = data.frame(unique(df5))
data1


```


```{r include=FALSE}
head(nb_dys)
head(cohab)

length(nb_dys) #351

df5 <- data.frame(nb_dys=nb_dys,cohab=cohab)
liste2 = c()

nb_dys_unique = sort(unique(nb_dys))
cohab_unique=sort(unique(cohab))
for ( k in 1:nrow(df5)){
  dys <- df5[k,"nb_dys"]
  coh <- df5[k,"cohab"]
  n = nrow(df5[which(df5$nb_dys==dys & df5$cohab==coh),])
  liste2=c(liste2,n)
    }


df5$nb_concernees = liste2

df5


```

```{r echo=FALSE}
df6 = distinct(df5)
df6$Categorie <- factor(df6$cohab, levels = 1:length(label_COHABITATION),labels=label_COHABITATION)


df6$nb_dys = as.factor(df6$nb_dys)
df6$cohab = as.factor(df6$cohab)

# Créer le diagramme à barres empilées
p <- ggplot(df6, aes(x = Categorie, y = nb_concernees, fill =nb_dys)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_brewer(palette = "Reds", name = "Nb de Dysfonctionnements") +
  labs(title = "Nombre de dysfonctionnements et temps de cohabitation",
       x = "Temps de cohabitation",
       y = "Nombre de personnes concernées") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="orangered3"),
        axis.title.x = element_text(face = "bold",colour="orangered3"),
        axis.title.y = element_text(face = "bold",colour="orangered3"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif  
```

On remarque que ceux qui ont cohabité avec le(s) problème(s) peu de temps étaient ceux qui en rencontraient plusieurs en même temps. 
```{r include=FALSE}
indice_colonne <- which(names(data) == "RECENCE_PROBLEMES_A1")
print(indice_colonne) # 106

indice_colonne <- which(names(data) == "REPARATION_A1")
print(indice_colonne) # 81

indice_colonne <- which(names(data) == "RECENCE_PROBLEMES_A25")
print(indice_colonne) # 80

indice_colonne <- which(names(data) == "REPARATION_A25")
print(indice_colonne) #105

81-56

```
