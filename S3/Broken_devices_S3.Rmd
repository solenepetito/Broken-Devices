---
title: 'Project : Broken devices S3'
author: "Solène PETITO"
output:
  html_document: default
  pdf_document: default
  word_document: default
date: "2024-06-17"
editor_options: 
  markdown: 
    wrap: 72
---

# **SEMAINE DU 17 JUIN 2024 au 21 JUIN 2024 :**

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
############### MODULE 1 : Chargement des librairies

library(readxl)
library(ggplot2)
library(stringr)
library(tibble)
library(dplyr)
library(plotly) # permet de faire des graphes intéractifs
library(corrplot) # permet de réqliser des matrices de corrélation
library(tidyr)

```

```{r include=FALSE}
############### MODULE 2 : Création de fonctions

# fonction func1 qui prend en entrée un jeu de données (don) et le nom d'une colonne de type Cri (Caratère répétitive) de ce jeu de données (colonne), sous forme de chaine de caractères et sans préciser de numéro à la fin de celle-ci  : ex : "COHABITATION_DYSFONCTION_A" ou "GENE_PROBLEMES_A". Elle renvoit en sortie une matrice a 2 lignes et 25 colonnes, indiquant en ligne 1 le type de dysfonctionnement, et en ligne 2 une modalité moyenne calculée pour la variable donnée en entrée pour chaque type de dysfonctionnements.

func1 <- function (don,colonne){
  matrice <- matrix(0,nrow=2,ncol=25)
  matrice[1,] <- c(1:25)
  df = don[which(don$RIDENTIFICATION_PROBLEMES!="27"),]
  variable=df$RIDENTIFICATION_PROBLEMES
  for (pb in 1:25){
    vec=c()
    for (i in 1:length(variable)){
      ligne=str_extract_all(variable[i], ".{2}")[[1]]
      ligne=sub("^0+", "", ligne)
      if (pb %in% ligne){
        num=as.character(pb)
        nom_colonne=paste0(colonne,num)
        valeur=df[i,nom_colonne]
        if(!is.null(valeur) && !is.na(valeur)){
          vec=c(vec,valeur)
        }
      }
    }
    if (length(vec) > 0) {
    matrice[2, pb] <- round(mean(vec))
  } else {
    matrice[2, pb] <- 0
  }
  }
  return(matrice)
}
##########################################

# Création d'une fonction **Count_VCM** (VCM = Variable à choix multiples) permettant d'afficher pour les variables à choix multiples UNIQUEMENT, le nombre de fois où chaque modalité est renseignée dans toute la colonne. Elle prend en entrée une variable à choix multiple (*variable*), issue de la base de données, et son nombre total de modalités (*nb_de_modalites*), et renvoit une matrice indiquant en ligne 1 le numéro de la modalité, et en ligne 2 le nombre de fois où les répondants l'on choisit.

Count_VCM <- function(variable,nb_de_modalites){
  mat <- matrix(0,nrow=2,ncol=nb_de_modalites)
  mat[1,]=c(1:nb_de_modalites)
  for (i in 1:length(variable)){
    ligne=str_extract_all(variable[i],".{2}")[[1]]
    vec=sub("^0+","",ligne)
    for (j in 1:length(vec)){
      for (k in 1:ncol(mat)){
        if (vec[j]==mat[1,k]){
          mat[2,k]=mat[2,k]+1
        }
      }
    }
  }
  return(mat)
}

##########################################

# Pour éviter d'avoir à afficher les numéros des modalités sur chaques graphes, je stocke directement les libellés des modalités dans des vecteurs

label_RIDENTIFICATION_PROBLEME = c("Problème avec l’écran","Problème de sensibilité du tactile","Problème avec l’appareil photo","Problème avec la lampe torche ou le flash","Problème avec le GPS","Problème avec le micro","Problème de son","Problème de prise jack","Problème de chargement","Problème de batterie","Problème de Wi-Fi","Problème de capteurs","Problème de Bluetooth ou de transferts de fichiers sans fil","Problème de téléphonie","Problème d’accès à Internet","Problème avec les boutons","Problème de vibreur","Stockage saturé","Système d’exploitation non mis à jour","Applications ne pouvant pas être téléchargées ou mises à jour","Problème lié à une fonctionnalité manquante","Fonctionnalité qui ne marche plus","Dysfonctionnement logiciel","Problèmes avec des applications","Problème de lenteur","Autre")

label_ACQUISITION = c("Quelqu’un me l’a offert ou donné","Quelqu’un me l’a prêté","Je l’ai acheté","Je l’ai obtenu dans le cadre de mon contrat avec mon opérateur","Mon employeur me l’a fourni","Je l’ai loué","Je ne me souviens pas","Obtenu par un autre moyen")

label_COHABITATION = c("Dès que j’ai décelé le dysfonctionnement","Moins d’un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de deux ans","Je ne sais pas" )

label_GENE=c("Très gênant","Plutôt gênant","Plutôt pas gênant","Pas gênant du tout")

label_INT_REPARATION= c("Oui, par moi-même","Oui, par le SAV ou un réparateur","Oui, par une connaissance","Pas pour l’instant", "Non")

label_RECENCE <- c("Dès la première utilisation","En moins de 3 mois","Entre 3 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Plus de 3 ans","Je ne sais pas")

# label_REPARATION <- c("Oui et le problème est resolu","Oui mais le problème na pas pu être résolu","Non, le problème s’est résolu tout seul au bout d’un moment","Non, peut être plus tard","Non, je ne pense pas tenter de résoudre le problème")

label_REPARATION <- c("Yes, and the problem is resolved", "Yes, but the problem could not be resolved","No, the problem resolved itself after a while","No, maybe later","No, I don't think I'll try to solve the problem")

```

**OBJECTIF :** *Analyser la base de données*

## **ANALYSE DE LA BASE DE DONNÉES**

### **I ) Import de la nouvelle base de données formattée**

```{r}
# Import des données

data <- readRDS("/home/solene_petito/Bureau/Stage/Broken_devices/data/data1.rds") # base de données sur laquelle on va appliquer tous les changements

Broken_Devices_Data <- read.csv("/home/solene_petito/Bureau/Stage/Broken_devices/data/Broken-Devices-Data1-xlsx.csv",row.names=1) # base de données initiale sur laquelle on pourra se référer pour voir si les chgts ont bien été appliqués

# nombre d'observations
nb_obs <- nrow(data) # 968 

# nombre de variables 
nb_var <- ncol(data) # 164
```

```{r include=FALSE}
View(data)
View(Broken_Devices_Data)
```

### **II ) Dysfonctionnement et date d'obtention du smartphone**

Le tableau suivant donne le pourcentage de personnes , dans la base de
données, qui ont leur téléphone depuis 2000, depuis 2001..., et le
pourcentage de personnes parmis celles-ci qui rencontrent des
dysfonctionnements :

```{r echo=FALSE}
valeurs <- t(as.matrix(tapply(data$poids, data$DATEOBTENTIONSMART_1, sum))) 
annees <- sort(unique(data$DATEOBTENTIONSMART_1))
nb_individus <- sum(data$poids)
mat=matrix(0,nrow=3,ncol=length(annees))
mat[1,]=annees
mat[2,]=round(valeurs)
for (i in 1:length(annees)){
  df <- data[which(data$DATEOBTENTIONSMART_1==mat[1,i] & data$RIDENTIFICATION_PROBLEMES!="27"),]
  nb_avec_pbs=sum(df$poids)
  mat[3,i]=round(nb_avec_pbs)

  
}
df <- data.frame("Année obtention"=mat[1,],"Nombre de personnes"=mat[2,],"Nombre_personnes_pbs" =mat[3,] ,"Pourcentage de personnes avec pb"=round(mat[3,]*100/mat[2,]))
print(df)
```

Le graphique à barres suivant donne le nombre de personnes , dans la
base de données, qui ont leur téléphone depuis 2000, depuis 2001..., et
qui recontrent des dysfonctionnements ou pas :

```{r echo=FALSE}

df_T1 <- data.frame(Annee = mat[1,], valeurs = mat[3, ], Legende = "Dysfonctionnements")
df_T2 <- data.frame(Annee = mat[1,], valeurs = mat[2, ], Legende = "Pas de dysfonctionnements")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Annee, y = valeurs, fill = Legende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" so on veut des barres côtes à côtes
  labs(title = "Problèmes rencontrés en fonction de l'année d'obtention",
       x = "Année d'obtention",
       y = "Nombre de personnes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 

```

On observe que la plupart des dysfonctionnements ont lieu sur des années
récentes d'obtention du smartphone, sur les 5 dernières années même. Les
personnes qui rencontrent des dysfonctionnements l'ont en grande
majorité depuis 2022 (108 personnes), 80 personnes depuis 2023 et 83
depuis 2021.

```{r echo=FALSE}
# Parmis les individus qui rencontrent un pb combien ont leur téléphone depuis 5 ans ?

mat= t(as.matrix(table(data[which(data$RIDENTIFICATION_PROBLEMES!="27"),"DATEOBTENTIONSMART_1"])))

# Parmis toute la base combien ont leur téléphone de depuis 5 ans et rencontrent un pb ?

pourcent2 <- round(sum(mat[11:15]) *100 / nrow(data)) # 91 %
print(paste("Pourcentage de personnes dans la base qui rencontrent un pbs et qui ont leur smartphone depuis moins de 5 ans :",pourcent2, "%"))


# Années de 2019 à 2023 = position 11 à position 15 de l'objet "mat"

nb_individus_avec_pbs <- nrow(data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]) # 400 individus qui rencontrent un pbs dans la base 
pourcent1 <- round(sum(mat[11:15]) *100 / nb_individus_avec_pbs) # 91 %
print(paste("Pourcentage de personnes parmis celles qui rencontrent un pbs qui ont leur smartphone depuis moins de 5 ans :",pourcent1, "%"))

```

Autre représenation mais sous forme de nuage de points représentant le
nombre de dysfonctionnements rencontrés par chacun des propriétaires en
fonction de l'année d'obtention de leur smartphone, plus le point est
gros plus le nombre de personnes dans le cas concidéré est important :

```{r echo=FALSE}
annees <- c()
dys <- c()
poids = c()
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
date=df$DATEOBTENTIONSMART_1
pbs=df$RIDENTIFICATION_PROBLEMES
for(i in 1:length(date)){
  annees=c(annees,date[i])
  liste_pbs=str_extract_all(pbs[i], ".{2}")[[1]]
  dys=c(dys,length(liste_pbs))
  poids =c(poids,df[i,"poids"])

}

dataframe <- data.frame(Obtention=annees,Nb_dysfonctionnements=dys, Poids = poids)

Nb_personnes_concernees <- c()
for (i in 1:nrow(dataframe)){
  annee=dataframe[i,1]
  dysfonc=dataframe[i,2]
  don <- dataframe[which(dataframe$Obtention==annee & dataframe$Nb_dysfonctionnements==dysfonc),]
  Nb_personnes_concernees <- c(Nb_personnes_concernees,round(sum(don$Poids)))
}

df2 <- data.frame(Obtention=annees,Nb_dysfonctionnements=dys,Nb_personnes_concernees=Nb_personnes_concernees)
df2 <- unique(df2)

# Créer le graphique interactif
p <- ggplot(df2, aes(x = Obtention, y = Nb_dysfonctionnements, size = Nb_personnes_concernees)) +
  geom_point(alpha = 0.7,col="darkgreen") +
  theme_minimal() +
  labs(title = "Nombre de dysfonctionnements en fonction de l'année d'obtention",
       x = "Année d'obtention",
       y = "Nombre de dysfonctionnement(s)",
       size = "Nb de personne(s) concernée(s)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="darkgreen"),
        axis.title.x = element_text( face = "bold",colour="darkgreen"),
        axis.title.y = element_text(face = "bold",colour="darkgreen"))

p_interactif <- ggplotly(p, tooltip = c("x", "y", "size"))

# Afficher le graphique interactif
p_interactif

```

```{r echo=FALSE}
df <- df2 %>% 
  arrange( Obtention,Nb_dysfonctionnements)

df
```


### **III ) Acquisition du smartphone**

#### **1 ) Comment les propriètaires ont-ils acquis leur smarthphone dans la base de données ? :**

Représentation sous forme de nuage de points, afin de mieux voir la
répartition :

```{r echo=FALSE}

# Exemple fictif des labels pour le type d'acquisition
unique_vals <- sort(unique(data$ACQUISITIONTEL))

# Créer le DataFrame pour ggplot
obs <- c(1:nrow(data))
ACQUISITIONTEL <- data$ACQUISITIONTEL
don2 <- data.frame(Individus = obs, Acquisition = factor(ACQUISITIONTEL, levels = unique_vals, labels = label_ACQUISITION))

# Créer un graphique ggplot
p <- ggplot(don2, aes(x = Individus, y = Acquisition)) +
  geom_point(col="turquoise4") +
  labs(title = "Acquisition du téléphone",
       x = "Individus",
       y = "Type d'acquisition") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="turquoise4"),
        axis.title.x = element_text(face = "bold",colour="turquoise4"), 
        axis.text.y = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="turquoise4"))

# Convertir le graphique ggplot en graphique interactif avec plotly
p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif

```

On voit clairement que la ligne correspondant au fait que les
propriétaires ont acheté leur téléphone est continue, ce qui explique
que le nombre de personnes dans ce cas là est important, contrairement à
la ligne indiquant que le propriétaire l'a obtenu d'une autre manière,
qui ne contient qu'un seul point. Le tableau suivant donne plus de
détails :

```{r echo=FALSE}
modalites <- sort(unique(data$ACQUISITIONTEL))
val=as.matrix(tapply(data[which(data$RIDENTIFICATION_PROBLEMES=="27"),"poids"], data[which(data$RIDENTIFICATION_PROBLEMES=="27"),"ACQUISITIONTEL"], sum)) 
dys <- as.matrix(tapply(data[which(data$RIDENTIFICATION_PROBLEMES!="27"),"poids"], data[which(data$RIDENTIFICATION_PROBLEMES!="27"),"ACQUISITIONTEL"], sum))
matrice=matrix(0,nrow=3,ncol=length(modalites))
matrice[1,]=modalites
matrice[2,]=val
matrice[3,1:6]=dys

Total=round(matrice[2,]+matrice[3,])
Pourcentage=round(Total*100/sum(data$poids),1)
df <- data.frame("Acquisition"=label_ACQUISITION,"Nombre de personnes"=Total,"Pourcentage"=Pourcentage)
print(df)

Total=round(matrice[3,])
Pourcentage=round(Total*100/(matrice[2,]+matrice[3]),1)

df2 <- data.frame("Acquisition"=label_ACQUISITION,"Nombre de personnes dys"=Total,"Pourcentage"=Pourcentage)
print(df2)
```



#### **2 ) Acquisition du smartphone et dysfonctionnements**

Regardons maintenant le nombre de personnes ayant rencontré un ou
plusieurs dysfonctionnements, en fonction du type d'acquisition de leur
téléphone :

```{r echo=FALSE}

Categorie <- factor(label_ACQUISITION, levels = label_ACQUISITION)

df_T1 <- data.frame(Categorie = Categorie, valeurs = matrice[3, ], Legende = "Dysfonctionnements")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2, ], Legende = "Pas de dysfonctionnements")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Legende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" so on veut des barres côtes à côtes
  labs(title = "Acquisition du téléphone",
       x = "Acquisition",
       y = "Nombre de personnes concernées") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 

```

On observe que la part de dysfonctionnements est plus grande pour la
modalité "je l'ai acheté", ce qui paraît logique car la modalité en
question représente 74% des personnes de la base. Il est donc préférable
de regarder la part de dysfonctionnement pour chacune des modalités.

En terme de pourcentage, le tableau suivant nous indique combien de
personnes pour chaque modalités a rencontré des dysfonctionnements :

```{r echo=FALSE}
modalites <- sort(unique(data$ACQUISITIONTEL))
matrice <- matrix(0,nrow=3,ncol=length(modalites))
matrice[1,]=modalites
for(i in 1:length(modalites)){
  df=data[which(data$ACQUISITIONTEL==modalites[i]),]
  n=nrow(df)
  personnes_pb=nrow(df[which(df$RIDENTIFICATION_PROBLEMES!="27"),])
  pourcent=personnes_pb*100/n
  matrice[2,i]=personnes_pb
  matrice[3,i]=round(pourcent)
}
# rajouter cette colonne si on veut plus de précision sur le pourcentage : `Nombre de personnes avec un pb`=mat[2,] 

frame=data.frame(Acquisition=label_ACQUISITION, `Pourcentage de personnes avec dys` =matrice[3,])
print(frame)
```

88 % de ceux dont le smartphone a été fourni par l'employeur rencontrent
un pb avec, 45% de ceux qui l'ont obtenu dans le cadre d'un contrat avec
leur opérateur en rencontrent un aussi, et 41 % de ceux qui l'ont acheté
en rencontrent.

### **IV ) Résolution du problème**

#### **1 ) Combien de problèmes ont été résolus ?**

La question posée était : **Avez-vous tenté de résoudre ou de faire
résoudre le(s) dysfonctionnement(s) rencontré(s) ?**

```{r include=FALSE}
# Cette matrice donne pour chaques problèmes le nombre de ceux ayant été résolus

vec=c(1:26)
matrice = matrix(0,nrow=6,ncol=length(vec))
matrice[1,]=vec
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]

for(i in 1:ncol(matrice)){
  pb=matrice[1,i]
  variable=df$RIDENTIFICATION_PROBLEMES
  for (j in 1:length(variable)){
    liste_pbs=str_extract_all(variable[j], ".{2}")[[1]]
    liste_pbs= sub("^0+", "", liste_pbs)
    if (pb %in% liste_pbs){
      num=as.character(pb)
      nom_colonne=paste0("REPARATION_A",num)
      valeur=df[j,nom_colonne]
      if (!is.na(valeur) &&!is.null(valeur) ){
        matrice[valeur+1,i]=matrice[valeur+1,i]+1
      }
    }
  }
}

print(matrice)

total_pbs_resolus <- sum(matrice[2,])+sum(matrice[4,]) #266
print(total_pbs_resolus)
```

```{r include=FALSE}
# Nombre total de problèmes rencontrés résolus par rapport au nombre total de problèmes rencontrés dans la base 

res <- Count_VCM(data$RIDENTIFICATION_PROBLEMES,26)
total_pbs=sum(res[2,])
print(total_pbs) #832
print(round(total_pbs_resolus*100/total_pbs)) #32%
```

Le graphe suivant montrent le pourcentage de personnes ayant répondu à
chaque modalités, parmis celles ayant indiqué qu'elles ont rencontré un
ou plusieurs dysfonctionnements :

```{r echo=FALSE}
REPARATION <- c(1:5)
matrice_REP=matrix(0,nrow=2,ncol=length(REPARATION))
matrice_REP[1,]=REPARATION

colonne_deb <- which(names(data) == "REPARATION_A1")
#print(colonne_deb) # 81

colonne_fin <- which(names(data) == "REPARATION_A25")
#print(colonne_fin) # 105

df <- data[,c(colonne_deb:colonne_fin,which(names(data) == "poids"))]

for (i in 1 :(ncol(df)-1)){
    for (j in 1:nrow(df)){
      val=df[j,i]
      if(!is.na(val)&& !is.null(val)){
        matrice_REP[2,val]=matrice_REP[2,val]+ df[j,"poids"]
      }
    }
  }

Categorie <- factor(label_REPARATION, levels = label_REPARATION)

df3 <- data.frame(Resolution = Categorie, Number = round(matrice_REP[2, ]*100/total_pbs))

# Créer un diagramme en barres empilées
p <- ggplot(df3, aes(x = Resolution, y = Number)) +
  geom_bar(stat = "identity",fill="darkgreen") + 
  labs(title = "Resolution of Malfunctions",
     x = "Malfunction Resolution",
     y = "Number of Malfunctions (in %)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="darkgreen"),
        axis.title.x = element_text( face = "bold",colour="darkgreen"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="darkgreen")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

```{r}
df <- data.frame(Resolution = Categorie,Nb_dys = round(matrice_REP[2,]), Pourcent = round(matrice_REP[2, ]*100/total_pbs))
df
```


Les problèmes ayant **tenté d'être résolus** représentent 32% des
problèmes rencontrés et ceux ayant **été résolus** représentent 18%.

#### **2 ) Analyse des 10 principaux dysfonctionnements rencontrés**

Les 10 principaux dysfonctionnements rencontrés sont les suivants :

```{r echo=FALSE}
matrice=Count_VCM(data$RIDENTIFICATION_PROBLEMES,26)
n=sum(data[which(data$RIDENTIFICATION_PROBLEMES!="27"),"poids"])

# Extraire les valeurs et les indices
values <- matrice[2, ]
indices <- matrice[1, ]

# Ordonner les valeurs en ordre décroissant et récupérer les indices correspondants
sorted_indices <- order(values, decreasing = TRUE)
sorted_values <- values[sorted_indices]
sorted_indices <- indices[sorted_indices]

# Sélectionner les 10 premières valeurs et indices
top_values <- sorted_values[1:10]
top_indices <- sorted_indices[1:10]

# Créer une nouvelle matrice avec les résultats
top_mat <- matrix(c(top_indices, top_values), nrow = 2, byrow = TRUE)
#print(top_mat)

# Conversion des matrices en data frames
df <- data.frame(Dysfonctionnement=factor(label_RIDENTIFICATION_PROBLEME[top_indices], levels = label_RIDENTIFICATION_PROBLEME[top_indices]), Pourcentage = round(top_mat[2,]*100/n))

# Créer un diagramme en barres empilées
p <- ggplot(df, aes(x = Dysfonctionnement, y = Pourcentage)) +
  geom_bar(stat = "identity",fill = "darkgreen") + # mettre position = "dodge" si on veut des barres côteà côte
  labs(title = "10 principaux dysfonctionnements rencontrés ",
       x = "Dysfonctionnements",
       y = "Pourcentage de dysfonctionnements") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="darkgreen"),
        axis.title.x = element_text(face = "bold",colour="darkgreen"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="darkgreen")) 

p_interactif <- ggplotly(p)

# Affichage du graphique interactif
p_interactif 

```

Il serait intéressant de savoir parmis ces 10 dysfonctionnements combien
ont tenté dêtre résout et combien ont été résolu ? Le tableau suivant nous
apporte plus de détails :

```{r echo=FALSE}
matrice = matrix(0,nrow=2,ncol=ncol(top_mat))
matrice[1,]=top_mat[1,]
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]

for(i in 1:ncol(matrice)){
  pb=matrice[1,i]
  variable=df$RIDENTIFICATION_PROBLEMES
  for (j in 1:length(variable)){
    liste_pbs=str_extract_all(variable[j], ".{2}")[[1]]
    liste_pbs= sub("^0+", "", liste_pbs)
    if (pb %in% liste_pbs){
      num=as.character(pb)
      nom_colonne=paste0("REPARATION_A",num)
      valeur=df[j,nom_colonne]
      if (!is.na(valeur) && (valeur == 1 || valeur == 3 )){
        matrice[2,i]=matrice[2,i]+ df[j,"poids"]
      }
    }
  }
}

#print(matrice)

df <- data.frame(Dysfonctionnement=label_RIDENTIFICATION_PROBLEME[top_indices], 'Nb_personnes'=round(top_mat[2,]),'Nb_personnes_résolu'=round(matrice[2,]),'Pourcentage_Nb_personnes_résolu'=round(matrice[2,]*100/top_mat[2,]))
print(df)
```

La plus grande part observée concerne le dysfonctionnement "Problème de
chargement" qui pour 33 pbs observés a été résolu dans 10 de ces cas, ce qui représente une part de 30% de résolution. Le graphe suivant permet de visualiser cette répartiton :

```{r echo=FALSE}
Categorie <- factor(label_RIDENTIFICATION_PROBLEME[top_indices], levels = label_RIDENTIFICATION_PROBLEME[top_indices])

df_T1 <- data.frame(Categorie = Categorie, valeurs = matrice[2, ], Legende = "Problème(s) résolu(s)")
df_T2 <- data.frame(Categorie = Categorie, valeurs = top_mat[2,]-matrice[2, ], Legende = "Problème(s) non résolu(s)")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Legende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" so on veut des barres côtes à côtes
  labs(title = "Résolution du problème",
       x = "Dysfonctionnement",
       y = "Nombre de dysfonctionnements ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

#### **3 ) Combien de personnes qui n'ont pas réparé cohabitent avec le problème ?**

```{r include=FALSE}

REPARATION <- c(1:5)
matrice <- matrix(0,nrow=7,ncol=length(REPARATION))
matrice[1,] <- REPARATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
for (i in 81:105){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_REP <- df[j,i]
      num_COHAB <- df[j,i+25]
      if (!is.na(num_COHAB) && !is.na(num_COHAB) ){
        matrice[num_COHAB+1,num_REP]=matrice[num_COHAB+1,num_REP]+1
      }
    }
}

print(matrice)


```

```{r include=FALSE}
matrice=matrix(0,nrow=3,ncol=5)
matrice[1,]=c(1:5)
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),c(81:105)]
for (j in 1:ncol(matrice)){
  for (i in 1:nrow(df)){
    if (j %in% df[i,]){
      matrice[2,j]=matrice[2,j]+1
    }
  
} 
}
matrice[3,]=round(matrice[2,]*100/nb_individus_avec_pbs)
print(matrice)
```

C'est 33% des personnes ayant rencontré un ou plusieurs
dysfonctionnements qui n'ont pas réussi à résoudre le ou les
dysfonctionnements.

### **V ) Temps de cohabitation avec le problème**

La question posée était : **Combien de temps s'est écoulé
approximativement entre le moment où vous avez décelé le(s)
dysfonctionnement(s) et le moment où vous avez tenté de le(s) résoudre
ou de le(s) faire résoudre ?**

#### **1 ) Personnes ayant tenté de résoudre le ou les dysfonctionnements**

On s'intéresse donc aux personnes ayant répondu aux 2 modalités
suivantes, lorsqu'on leur a demandé s'il avait tenté de résoudre le
problème, (c'est à dire 32% des dysfonctionnements) :

-   1 : Oui et le problème est résolu

-   2 : Oui mais le problème n'a pas pu être résolu

Voici les réponses obtenues :

```{r include=FALSE}
# Indice des colonnes réparation 

colonne_deb <- which(names(data) == "REPARATION_A1")
print(colonne_deb) # 81

colonne_fin <- which(names(data) == "REPARATION_A25")
print(colonne_fin) # 105

```

```{r include=FALSE}
# Cohabitation + réparation 

REPARATION <- c(1:5)
matrice <- matrix(0,nrow=7,ncol=length(REPARATION))
matrice[1,] <- REPARATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
for (i in 81:105){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_REP <- df[j,i]
      num_COHAB <- df[j,i+25]
      if (!is.na(num_COHAB) && !is.na(num_REP) ){
        matrice[num_COHAB+1,num_REP]=matrice[num_COHAB+1,num_REP]+round(df[j,"poids"])
      }
    }
}
print(matrice)
```

```{r echo=FALSE}
total = sum(matrice_REP[2,1:2]) # 351

COHABITATION <- c(1:6)
matrice=matrix(0,nrow=2,ncol=length(COHABITATION))
matrice[1,]=COHABITATION

df <- data[, c(106:130,which(names(data) == "poids"))]

for (k in 1:ncol(matrice)){
  for (i in 1 :(ncol(df)-1)){
    for (j in 1:nrow(df)){
      val=df[j,i]
      if(!is.na(val) && val==k){
        matrice[2,k]=matrice[2,k]+df[j,"poids"]
      }
    }
  }
}

Categorie <- factor(label_COHABITATION, levels = label_COHABITATION)

df3 <- data.frame(Categorie = Categorie, valeurs = round(matrice[2, ]*100/total))

# Créer un diagramme en barres empilées
p <- ggplot(df3, aes(x = Categorie, y = valeurs)) +
  geom_bar(stat = "identity",fill="thistle4") + 
  labs(title = "Temps de cohabitation avec le problème",
       x = "Temps de cohabitation",
       y = "Pourcentage de dysfonctionnements (en %) ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="thistle4"),
        axis.title.x = element_text( face = "bold",colour="thistle4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="thistle4")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

```{r}
df <- data.frame(Cohabitation = label_COHABITATION, Nb_dys =round( matrice[2,]),Pourcent =round(matrice[2, ]*100/total) )

df
```


39 % des problèmes résolus l'ont été dés que le propriétaire du
smartphone l'a décelé. 32% ont été résolus en moins d'un mois et 15%
entre 1 et 6 mois.

#### **2) Incidence du genre sur le temps de cohabitation**

Le genre aurait-il une incidence sur ce temps de cohabitation ?

```{r echo=FALSE}
# Matrice des femmes
COHABITATION <- c(1:6)
matrice_femmes=matrix(0,nrow=2,ncol=length(COHABITATION))
matrice_femmes[1,]=COHABITATION

df <- data[which(data$SEXE==2),c(106:130,which(names(data) == "poids"))]

for (k in 1:ncol(matrice)){
  for (i in 1 :(ncol(df)-1)){
    for (j in 1:nrow(df)){
      val=df[j,i]
      if(!is.na(val) && val==k){
        matrice_femmes[2,k]=matrice_femmes[2,k]+df [j,"poids"]
      }
    }
  }
}

# Matrice des hommes 
COHABITATION <- c(1:6)
matrice_hommes=matrix(0,nrow=2,ncol=length(COHABITATION))
matrice_hommes[1,]=COHABITATION

df <- data[which(data$SEXE==1),c(106:130,which(names(data) == "poids"))]

for (k in 1:ncol(matrice)){
  for (i in 1 :(ncol(df)-1)){
    for (j in 1:nrow(df)){
      val=df[j,i]
      if(!is.na(val) && val==k){
        matrice_hommes[2,k]=matrice_hommes[2,k]+ df [j,"poids"]
      }
    }
  }
}

Categorie <- factor(label_COHABITATION, levels = label_COHABITATION)

df_T1 <- data.frame(Categorie = Categorie, valeurs = round(matrice_femmes[2, ]*100/total), Genre = "Femmes")
df_T2 <- data.frame(Categorie = Categorie, valeurs = round(matrice_hommes[2, ]*100/total), Genre = "Hommes")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Genre)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Temps de cohabitation avec le problème",
       x = "Temps de cohabitation",
       y = "Pourcentage de dysfonctionnements (en %) ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

```{r}
df_T1 <- data.frame(Categorie = Categorie, Nb_dys = round(matrice_femmes[2, ]) , Pourcent =round(matrice_femmes[2, ]*100/total), Genre = "Femmes")
df_T2 <- data.frame(Categorie = Categorie, Nb_dys = round(matrice_hommes[2, ]) ,Pourcent = round(matrice_hommes[2, ]*100/total), Genre = "Hommes")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2)

df <- df_combined %>% 
  arrange( Categorie,Genre)

df
```


Les hommes semblent régler le problème en moins d'un mois (20%) alors
que les femmes semblent le régler dès le dysfonctionnement est décelé
(22%).

#### **3 ) Boîte à moustache du temps de cohabitation**

Autre représentation mais sous forme de boites à moustache (distribution
du nombre de personnes par temps de cohabitation) :

```{r echo=FALSE}
df <- data[which(data$RIDENTIFICATION_PROBLEMES!="27"),c(106:130)]
filtered_columns <- list()

# Parcourir les colonnes du dataframe
for (i in 1:ncol(df)) {
  # Extraire la colonne
  column <- df[,i]
  column <- na.omit(column)
  filtered_columns = c(filtered_columns,column)
}

valeurs <- c()
for (j in 1:length(filtered_columns)){
  valeurs[j]=filtered_columns[[j]]
}

don <- data.frame(y=factor(valeurs, levels = sort(unique(valeurs)), labels = label_COHABITATION))
p <- ggplot(don)+aes(y=y)+geom_boxplot(fill="skyblue")+theme_minimal()+
  labs(title = "Boxplot du temps de cohabitation",
       y = "Temps de cohabitation") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="skyblue"),
        axis.title.x = element_text(face = "bold",colour="skyblue"),
        axis.title.y = element_text(face = "bold",colour="skyblue"),
        axis.text.y = element_text(angle = 45, hjust = 1, vjust = 1)) 
 
p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
 

```

#### **4 ) Nuage de points du temps de cohabitation**

```{r echo=FALSE }
don <- data.frame(obs=c(1:length(valeurs)),Cohabitation = factor(valeurs, levels = sort(unique(valeurs)), labels = label_COHABITATION)) # Ajouter une colonne numérique Temps
p <- ggplot(don, aes(x = obs, y =Cohabitation )) +
  geom_point(col="thistle4") +
  theme_minimal() +
  labs(title = "Nuage de points du temps de cohabitation",
       y = "Temps de cohabitation",
       x = "Individus") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="thistle4"),
        axis.title.x = element_text(face = "bold",colour="thistle4"),
        axis.title.y = element_text(face = "bold",colour="thistle4"),
        axis.text.y = element_text(angle = 45, hjust = 1, vjust = 1)) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 

```

### **VI ) Gênes ressenties**

Le graphe suivant donne les gênes qu'ont ressentis les propriétaires
suite au(x) dysfonctionnement(s) qu'ils ont rencontré :

```{r echo=FALSE}
GENE <- c(1:4)
matrice=matrix(0,nrow=2,ncol=length(GENE))
matrice[1,]=GENE

colonne_deb <- which(names(data) == "GENE_PROBLEMES_A1")
#print(colonne_deb) # 31

colonne_fin <- which(names(data) == "GENE_PROBLEMES_A25")
#print(colonne_fin) # 55

df <- data[,c(colonne_deb:colonne_fin,which(names(data) == "poids"))]
total_pbs = sum(df$poids)

for (k in 1:ncol(matrice)){
  for (i in 1 :ncol(df)){
    for (j in 1:nrow(df)){
      val=df[j,i]
      if(!is.na(val) && val==k){
        matrice[2,k]=matrice[2,k]+df[i,"poids"]
      }
    }
  }
}

Categorie <- factor(label_GENE, levels = label_GENE)



df3 <- data.frame(Categorie = Categorie, valeurs = round(matrice[2, ]*100/total_pbs))

# Créer un diagramme en barres empilées
p <- ggplot(df3, aes(x = Categorie, y = valeurs)) +
  geom_bar(stat = "identity",fill="tan4") + 
  labs(title = "Type de gênes ressenties",
       x = "Gênes ressenties par les propriétaires",
       y = "Pourcentage de dysfonctionnements (en %) ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="tan4"),
        axis.title.x = element_text( face = "bold",colour="tan4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="tan4")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 

```

```{r echo=FALSE}

df <- data.frame(Gêne = Categorie, Nb_dys =round(matrice[2,]) , Pourcent =round(matrice[2, ]*100/total_pbs))
df

```


47% des problèmes rencontrés ont été ressentis comme étant plutôt
gênant, 32% comme étant trés gênant, 18% comme étant plutôt pas gênant
et 3% comme pas gênant du tout.

### **VII ) Récence du dysfonctionnement**

La question posée était :**A partir de quel moment approximativement
avez-vous décelé les premiers dysfonctionnements sur votre smartphone
?**

```{r echo=FALSE}
RECENCE <- c(1:7)
matrice=matrix(0,nrow=2,ncol=length(RECENCE))
matrice[1,]=RECENCE

colonne_deb <- which(names(data) == "RECENCE_PROBLEMES_A1")
#print(colonne_deb) # 56

colonne_fin <- which(names(data) == "RECENCE_PROBLEMES_A25")
#print(colonne_fin) # 80

df <- data[,c(colonne_deb:colonne_fin)]

for (k in 1:ncol(matrice)){
  for (i in 1 :ncol(df)){
    for (j in 1:nrow(df)){
      val=df[j,i]
      if(!is.na(val) && val==k){
        matrice[2,k]=matrice[2,k]+1
      }
    }
  }
}

Categorie <- factor(label_RECENCE, levels = label_RECENCE)



df3 <- data.frame(Categorie = Categorie, valeurs = round(matrice[2, ]*100/total_pbs))

# Créer un diagramme en barres empilées
p <- ggplot(df3, aes(x = Categorie, y = valeurs)) +
  geom_bar(stat = "identity",fill="turquoise4") + 
  labs(title = "Récence des dysfonctionnements",
       x = "Récence des dysfonctionnements",
       y = "Pourcentage de dysfonctionnements (en %) ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="turquoise4"),
        axis.title.x = element_text( face = "bold",colour="turquoise4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="turquoise4")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

C'est 25% de personnes qui s'en sont rendus compte entre 3 mois et 1 an,
et 24% entre 1 an et 2 ans.

### **VIII ) Degrés de gêne par rapport au temps de cohabitation**

Est ce que le degré de gêne ressentis pour chaques dysfonctionnements
est différent selon les différents temps de cohabitation avec le ou les
dysfonctionnements ?

```{r include=FALSE}
COHABITATION <- c(1:6)
matrice <- matrix(0,nrow=5,ncol=length(COHABITATION))
matrice[1,] <- COHABITATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
for (i in 106:130){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_COHAB <- df[j,i]
      num_GENE <- df[j,i-75]
      if (!is.na(num_COHAB) && !is.na(num_GENE) ){
        matrice[num_GENE+1,num_COHAB]=matrice[num_GENE+1,num_COHAB]+ round(df[j,"poids"])
      }
    }
}
print(matrice)
```

```{r echo=FALSE}
COHABITATION <- c(1:6)
matrice <- matrix(0,nrow=5,ncol=length(COHABITATION))
matrice[1,] <- COHABITATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
for (i in 106:130){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_COHAB <- df[j,i]
      num_GENE <- df[j,i-75]
      if (!is.na(num_COHAB) && !is.na(num_GENE) ){
        matrice[num_GENE+1,num_COHAB]=matrice[num_GENE+1,num_COHAB]+ df[j,"poids"]
      }
    }
}
#print(matrice)

Categorie <- factor(label_COHABITATION, levels = label_COHABITATION)

df_T1 <- data.frame(Categorie = Categorie, valeurs = round(matrice[2,]*100/total), GÊNE = "Trés gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = round(matrice[3,]*100/total), GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = round(matrice[4,]*100/total), GÊNE = "Plutôt pas gênant")
df_T4 <- data.frame(Categorie = Categorie, valeurs = round(matrice[5,]*100/total), GÊNE = "Pas gênant du tout")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3, df_T4)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Type de gênes et temps de cohabitation",
       x = "Temps de cohabitation",
       y = "Pourcentage de dysfonctionnements (en %) ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

```{r}
df_T1 <- data.frame(Categorie = Categorie,Nb_dys = round(matrice[2,]), Pourcent = round(matrice[2,]*100/total), GÊNE = "Trés gênant")
df_T2 <- data.frame(Categorie = Categorie,Nb_dys = round(matrice[3,]), Pourcent = round(matrice[3,]*100/total), GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie,Nb_dys = round(matrice[4,]), Pourcent = round(matrice[4,]*100/total), GÊNE = "Plutôt pas gênant")
df_T4 <- data.frame(Categorie = Categorie,Nb_dys = round(matrice[5,]), Pourcent = round(matrice[5,]*100/total), GÊNE = "Pas gênant du tout")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3, df_T4)

df <- df_combined %>% 
  arrange( Categorie,GÊNE)

df
```


On voit que lorsque le dysfonctionnement a été décelé dés son
apparition, le problème a été ressentis comme étant trés gênant. Lorsque
le propriétaire a cohabité avec le dysfonctionnement moins d'un mois le
dysfonctionnement a été ressentis comme étant majoritairement plutôt
gênant.

### **IX ) Intention de réparation**

La question posée était : **Vous nous avez déclaré ne pas avoir tenté de
résoudre les dysfonctionnements suivants de votre smartphone.
Envisagez-vous de tenter de le(s) résoudre ?**

Les réponses possibles étaient :

-   1 : Oui, par moi-même

-   2 : Oui, par le SAV ou un réparateur

-   3 : Oui, par une connaissance

-   4 : Pas pour l'instant

-   5 : Non

```{r include=FALSE}
REPARATION <- c(1:5)
matrice <- matrix(0,nrow=6,ncol=length(REPARATION))
matrice[1,] <- REPARATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27" ),]
for (i in 81:105){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_REP <- df[j,i]
      num_INT <- df[j,i+50]
      if (!is.na(num_REP) && !is.na(num_INT) ){
        matrice[num_INT+1,num_REP]=matrice[num_INT+1,num_REP]+1
      }
    }
}
print(matrice)
nb_personnes <-sum(matrice[2:6,4])+(matrice[2:6,5])

```

Cela ne concerne que les personnes ayant répondu aux modalités 4(Non,
peut être plus tard) et 5 (Non, je ne pense pas tenter de résoudre le
problème) à la question "Avez vous tenté de résoudre le problème" Ce qui
représente 40% des personnes ayant rencontré des dysfonctionnements.

```{r include=FALSE}
REPARATION <- c(1:5)

# CSP 1
matrice_CSP1 <- matrix(0,nrow=6,ncol=length(REPARATION))
matrice_CSP1[1,] <- REPARATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27" & data$CSP5==1),]
for (i in 81:105){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_REP <- df[j,i]
      num_INT <- df[j,i+50]
      if (!is.na(num_REP) && !is.na(num_INT) ){
        matrice_CSP1[num_INT+1,num_REP]=matrice_CSP1[num_INT+1,num_REP]+1
      }
    }
}
CSP1 <- c(matrice_CSP1[2:6,4]+matrice_CSP1[2:6,5])

# CSP 2
matrice_CSP2 <- matrix(0,nrow=6,ncol=length(REPARATION))
matrice_CSP2[1,] <- REPARATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27" & data$CSP5==2),]
for (i in 81:105){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_REP <- df[j,i]
      num_INT <- df[j,i+50]
      if (!is.na(num_REP) && !is.na(num_INT) ){
        matrice_CSP2[num_INT+1,num_REP]=matrice_CSP2[num_INT+1,num_REP]+1
      }
    }
}
CSP2 <- c(matrice_CSP2[2:6,4]+matrice_CSP2[2:6,5])

# CSP 3
matrice_CSP3 <- matrix(0,nrow=6,ncol=length(REPARATION))
matrice_CSP3[1,] <- REPARATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27" & data$CSP5==3),]
for (i in 81:105){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_REP <- df[j,i]
      num_INT <- df[j,i+50]
      if (!is.na(num_REP) && !is.na(num_INT) ){
        matrice_CSP3[num_INT+1,num_REP]=matrice_CSP3[num_INT+1,num_REP]+1
      }
    }
}
CSP3 <- c(matrice_CSP3[2:6,4]+matrice_CSP3[2:6,5])

# CSP 4
matrice_CSP4 <- matrix(0,nrow=6,ncol=length(REPARATION))
matrice_CSP4[1,] <- REPARATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27" & data$CSP5==4),]
for (i in 81:105){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_REP <- df[j,i]
      num_INT <- df[j,i+50]
      if (!is.na(num_REP) && !is.na(num_INT) ){
        matrice_CSP4[num_INT+1,num_REP]=matrice_CSP4[num_INT+1,num_REP]+1
      }
    }
}
CSP4 <- c(matrice_CSP4[2:6,4]+matrice_CSP4[2:6,5])

# CSP 5
matrice_CSP5 <- matrix(0,nrow=6,ncol=length(REPARATION))
matrice_CSP5[1,] <- REPARATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27" & data$CSP5==5),]
for (i in 81:105){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_REP <- df[j,i]
      num_INT <- df[j,i+50]
      if (!is.na(num_REP) && !is.na(num_INT) ){
        matrice_CSP5[num_INT+1,num_REP]=matrice_CSP5[num_INT+1,num_REP]+1
      }
    }
}
CSP5 <- c(matrice_CSP5[2:6,4]+matrice_CSP5[2:6,5])

```

Diagramme en barres pour chaques CSPs en fonction de l'intention de
réparation :

```{r echo=FALSE}
Categorie <- factor(label_INT_REPARATION, levels = label_INT_REPARATION)

df_T1 <- data.frame(Categorie = Categorie, valeurs =round(CSP1*100/nb_personnes) , CSP = "CSP+")
df_T2 <- data.frame(Categorie = Categorie, valeurs =round(CSP2*100/nb_personnes) , CSP = "CSP-")
df_T3 <- data.frame(Categorie = Categorie, valeurs =round(CSP3*100/nb_personnes) , CSP = "Retraités")
df_T4 <- data.frame(Categorie = Categorie, valeurs =round(CSP4*100/nb_personnes) , CSP = "Étudiants")
df_T5 <- data.frame(Categorie = Categorie, valeurs =round(CSP5*100/nb_personnes) , CSP = "Autre Inactifs")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3, df_T4,df_T5)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = CSP)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Intention de réparation",
       x = "Intention de réparation",
       y = "Pourcentage de dysfonctionnements (en %) ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

p_interactif

# Afficher le graphique interactif
```

```{r}
df_combined

df <- df_combined %>% 
  arrange(Categorie,CSP)

df
```


