---
title: 'Project : Broken devices S5'
author: "Solène PETITO"
output:
  html_document: default
  pdf_document: default
  word_document: default
date: "2024-07-01"
editor_options: 
  markdown: 
    wrap: 72
---

# **SEMAINE DU 1 JUILLET 2024 au 5 JUILLET 2024 :**

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
############### MODULE 1 : Chargement des librairies

library(readxl)
library(ggplot2)
library(stringr)
library(tibble)
library(dplyr)
library(plotly) # permet de faire des graphes intéractifs
library(corrplot) # permet de réqliser des matrices de corrélation
library(tidyr)
library(RColorBrewer) # librairie pour les palettes de couleurs
library(viridis) # palette de couleurs > 25 nuances
library(Polychrome)
library(gridExtra) # afficher les graphes côte à côte
library(grid)

```

```{r include=FALSE}
############### MODULE 2 : Création de fonctions

# fonction func1 qui prend en entrée un jeu de données (don) et le nom d'une colonne de type Cri (Caratère répétitive) de ce jeu de données (colonne), sous forme de chaine de caractères et sans préciser de numéro à la fin de celle-ci  : ex : "COHABITATION_DYSFONCTION_A" ou "GENE_PROBLEMES_A". Elle renvoit en sortie une matrice a 2 lignes et 25 colonnes, indiquant en ligne 1 le type de dysfonctionnement, et en ligne 2 une modalité moyenne calculée pour la variable donnée en entrée pour chaque type de dysfonctionnements.

func1 <- function (don,colonne){
  matrice <- matrix(0,nrow=2,ncol=25)
  matrice[1,] <- c(1:25)
  df = don[which(don$RIDENTIFICATION_PROBLEMES!="27"),]
  variable=df$RIDENTIFICATION_PROBLEMES
  for (pb in 1:25){
    vec=c()
    for (i in 1:length(variable)){
      ligne=str_extract_all(variable[i], ".{2}")[[1]]
      ligne=sub("^0+", "", ligne)
      if (pb %in% ligne){
        num=as.character(pb)
        nom_colonne=paste0(colonne,num)
        valeur=df[i,nom_colonne]
        if(!is.null(valeur) && !is.na(valeur)){
          vec=c(vec,valeur)
        }
      }
    }
    if (length(vec) > 0) {
    matrice[2, pb] <- round(mean(vec))
  } else {
    matrice[2, pb] <- 0
  }
  }
  return(matrice)
}
##########################################

# Création d'une fonction **Count_VCM** (VCM = Variable à choix multiples) permettant d'afficher pour les variables à choix multiples UNIQUEMENT, le nombre de fois où chaque modalité est renseignée dans toute la colonne. Elle prend en entrée une variable à choix multiple (*variable*), issue de la base de données, et son nombre total de modalités (*nb_de_modalites*), et renvoit une matrice indiquant en ligne 1 le numéro de la modalité, et en ligne 2 le nombre de fois où les répondants l'on choisit.

Count_VCM <- function(variable,nb_de_modalites){
  mat <- matrix(0,nrow=2,ncol=nb_de_modalites)
  mat[1,]=c(1:nb_de_modalites)
  for (i in 1:length(variable)){
    ligne=str_extract_all(variable[i],".{2}")[[1]]
    vec=sub("^0+","",ligne)
    for (j in 1:length(vec)){
      for (k in 1:ncol(mat)){
        if (vec[j]==mat[1,k]){
          mat[2,k]=mat[2,k]+1
        }
      }
    }
  }
  return(mat)
}

##########################################

# Pour éviter d'avoir à afficher les numéros des modalités sur chaques graphes, je stocke directement les libellés des modalités dans des vecteurs

label_RIDENTIFICATION_PROBLEME = c("Problème avec l’écran","Problème de sensibilité du tactile","Problème avec l’appareil photo","Problème avec la lampe torche ou le flash","Problème avec le GPS","Problème avec le micro","Problème de son","Problème de prise jack","Problème de chargement","Problème de batterie","Problème de Wi-Fi","Problème de capteurs","Problème de Bluetooth ou de transferts de fichiers sans fil","Problème de téléphonie","Problème d’accès à Internet","Problème avec les boutons","Problème de vibreur","Stockage saturé","Système d’exploitation non mis à jour","Applications ne pouvant pas être téléchargées ou mises à jour","Problème lié à une fonctionnalité manquante","Fonctionnalité qui ne marche plus","Dysfonctionnement logiciel","Problèmes avec des applications","Problème de lenteur","Autre")

label_ACQUISITION = c("Quelqu’un me l’a offert ou donné","Quelqu’un me l’a prêté","Je l’ai acheté","Je l’ai obtenu dans le cadre de mon contrat avec mon opérateur","Mon employeur me l’a fourni","Je l’ai loué","Je ne me souviens pas","Obtenu par un autre moyen")

label_COHABITATION = c("Dès que j’ai décelé le dysfonctionnement","Moins d’un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de deux ans","Je ne sais pas" )

label_GENE=c("Très gênant","Plutôt gênant","Plutôt pas gênant","Pas gênant du tout")

label_INT_REPARATION= c("Oui, par moi-même","Oui, par le SAV ou un réparateur","Oui, par une connaissance","Pas pour l’instant", "Non")

label_RECENCE <- c("Dès la première utilisation","En moins de 3 mois","Entre 3 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Plus de 3 ans","Je ne sais pas")

label_REPARATION <- c("Oui et le problème est resolu","Oui mais le problème na pas pu être résolu","Non, le problème s’est résolu tout seul au bout d’un moment","Non, peut être plus tard","Non, je ne pense pas tenter de résoudre le problème")

label_OS <- c("IOS (Apple)","Android","Autre","Je ne sais pas")

label_ETAT= c("Neuf","D'occasion","Reconditionné","Je ne sais pas" )

label_COHAB_2 <- c("Moins d'un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de 2 ans")

label_RAISON_UTIL_PB <- c("Cela serait trop coûteux de résoudre le(s) problème(s) ou de remplacer mon smartphone",
"J’attends une opportunité", "Je ne peux pas résoudre le problème car le smartphone ne m’appartient pas","Je ne sais pas comment résoudre le(s) problème(s)","Je veux faire durer mon téléphone le plus longtemps possible","Ce(s) problème(s) ne m’impacte(nt) pas tant que ça au quotidien","Je n’ai pas pris le temps de m’en occuper, de chercher une solution","Mon téléphone est trop récent pour que je le fasse réparer ou que je le remplace","La résolution du (ou des) problème(s) est trop difficile ou incertaine","Ça me donne un prétexte pour moins l’utiliser","Cela ne vaut pas la peine de résoudre le(s) problème(s)","Mon smartphone a une particularité difficile à retrouver si je devais le remplacer","Autre")

label_IMPACT <- c("Usage global du smartphone","Communication ","Réseaux sociaux ","Cartes et guidage GPS","Jeux","Navigation web","Streaming musique et vidéo","Outils de productivité ","Logiciels et applications professionnelles dédiées","Photo, vidéo et autres activités de création","Identification bancaire, paiement sans contact","Tickets dématérialisés ","Courses et achats en ligne","Autre","Aucun")
```

**OBJECTIF :** *Analyser la base de données*

## **ANALYSE DE LA BASE DE DONNÉES**

```{r include=FALSE}
# Import des données

data <- readRDS("/home/solene_petito/Bureau/Stage/Broken_devices/data/data1.rds") # base de données sur laquelle on va appliquer tous les changements

Broken_Devices_Data <- read.csv("/home/solene_petito/Bureau/Stage/Broken_devices/data/Broken-Devices-Data1-xlsx.csv",row.names=1) # base de données initiale sur laquelle on pourra se référer pour voir si les chgts ont bien été appliqués

# nombre d'observations
nb_obs <- nrow(data) # 968 

# nombre de variables 
nb_var <- ncol(data) # 164
```

```{r include=FALSE}
View(data)
View(Broken_Devices_Data)
```

### **I ) Degrés de gêne par temps de cohabitation de ceux qui n'ont pas réparé**

Précédemment il a été calculé le temps de cohabitation de ceux qui
n'avait pas tenté de résoudre le(s) dysfonctionnement(s). Le graphe qui
suit permet de montrer pour chaque temps de cohabitation, le degré de
gêne qui a été ressenti pour chacun d'eux :

```{r include=FALSE}
# Initialisation des vecteurs pour stocker les valeurs de recence, année, et mois
recence <- c()
annee <- c()
mois <- c()
gene <- c()

# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105 (indice des colonnes reparation)
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 4 || val == 5)) {
      RECENCE <- df[j, i - 25]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(RECENCE)) {
        recence <- c(recence, RECENCE)
        annee <- c(annee, df[j, "DATEOBTENTIONSMART_1"])
        mois <- c(mois, df[j, "DATEOBTENTIONSMART_2"])
        gene <- c(gene,df[j, i - 50])
      }
    }
  }
}

# Suppression de la raison 7 dans la liste recence 

indices_rec_7= which(recence==7)
gene=gene[-c(indices_rec_7)]

# Afficher les résultats pour vérifier
print(head(recence))
print(head(annee))
print(head(mois))
print(head(gene))
```

```{r include=FALSE}
COHAB_non_resolus <- c( 3, 2, 3, 4, 4, 4, 3, 3, 3, 4, 4, 4, 3, 4, 3, 4, 1, 3, 3, 2, 2, 4, 4, 3, 4, 4, 2, 3, 4, 3, 3, 4, 3, 4, 3, 2, 3, 1, 3, 4, 2, 2, 3, 3, 4, 4, 3, 2, 4,2, 3, 3, 3, 2, 3, 3, 3, 4, 3, 4, 2, 3, 3, 2, 4, 4, 3, 4, 2, 4, 3, 4, 3, 3, 3, 4, 2, 3, 4, 3, 3, 4, 3, 4, 4, 4, 4, 4, 2, 3, 2, 2, 4, 3, 3, 2, 3, 3,4, 4, 3, 2, 3, 4, 4, 3, 3, 4, 3, 3, 3, 4, 4, 2, 4, 4, 2, 4, 3, 4, 4, 3, 3, 4, 4, 4, 3, 4, 2, 3, 1, 2, 4, 3, 3, 4, 4, 3, 4, 3, 3, 4, 4, 4, 3, 4, 3,3, 4, 3, 4, 2, 2, 3, 3, 1, 2, 3, 2, 3, 3, 4, 4, 3, 4, 3, 3, 4, 4, 4, 3, 3, 2, 4, 3, 1, 2, 3, 4, 2, 4, 3, 4, 4, 4, 3, 3, 4, 3, 3, 2, 3, 2, 4, 4, 4,3, 4, 3, 3, 1, 3, 2, 4, 4, 3, 2, 4, 3, 4, 3, 4, 3, 4, 4, 4, 3, 4, 3, 3, 2, 4, 3, 3, 4, 2, 2, 4, 3, 3, 3, 4, 1, 4, 4, 4, 3, 3, 4, 3, 4, 2, 3, 4, 3,4,3 ,4 ,4 ,4 ,4 ,4, 3, 4, 3, 4, 2, 3, 4, 3, 3, 3, 3, 4, 4, 2, 4, 4, 4, 3, 2, 3, 4, 4, 4, 3, 3, 2, 3, 4, 3, 4, 4, 4, 3, 2, 4, 4, 1, 3, 2, 4, 4, 3,2, 4, 4, 3, 4, 4, 4, 4, 3, 2, 4, 3, 4, 4, 3, 4, 3, 1, 3, 3, 2, 3)

nb_non_resolus <- length(COHAB_non_resolus) # 316
```

```{r include=FALSE}
val=sort(unique(COHAB_non_resolus))
total=as.matrix(table(COHAB_non_resolus))

mat=matrix(0,nrow=5,ncol=length(val))
mat[1,]=val # temps de cohabitation sur la ligne 1 de la matrice 

for (i in val){
  indices=which(COHAB_non_resolus==i)
  g = gene[c(indices)]
  freq=as.matrix(table(g))
  mat[2:(length(freq)+1),i]=freq
}
mat
# Définir une fonction de normalisation
normalize <- function(x) {
  return(round(x*100/total))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat <- t(apply(mat[2:5,], 1, normalize))
print(normalized_mat)

```

```{r include=FALSE}
Categorie <- factor(label_COHAB_2, levels = label_COHAB_2)

gene_levels <- c("Plutôt pas gênant", "Plutôt gênant", "Très gênant")

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[1,], Gêne = factor("Très gênant",levels=gene_levels))
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[2,], Gêne = factor("Plutôt gênant",levels=gene_levels))
df_T3 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[3,], Gêne = factor("Plutôt pas gênant",levels=gene_levels))


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)

# Créer un diagramme en barres empilées
p1 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Gêne)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Type de gênes par temps de cohabitation",
       x = "Temps de cohabitation",
       y = "Pourcentage de dysfonctionnements ") +
  scale_fill_manual(values = c("Très gênant" = "#1f77b4", 
                               "Plutôt gênant" = "#6baed6", 
                               "Plutôt pas gênant" = "#c6dbef")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="#1f77b4"),
        axis.title.x = element_text( face = "bold",colour="#1f77b4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="#1f77b4")) 

p1_interactif <- ggplotly(p1)

# Afficher le graphique interactif
p1_interactif  

```

```{r include=FALSE}
Categorie <- factor(label_COHAB_2, levels = label_COHAB_2)
gene_levels <- c("Plutôt pas gênant", "Plutôt gênant", "Très gênant")

df_T1 <- data.frame(Categorie = Categorie, valeurs = mat[2,]*100/nb_non_resolus, Gêne = factor("Très gênant",levels=gene_levels))
df_T2 <- data.frame(Categorie = Categorie, valeurs = mat[3,]*100/nb_non_resolus, Gêne = factor("Plutôt gênant",levels=gene_levels))
df_T3 <- data.frame(Categorie = Categorie, valeurs = mat[4,]*100/nb_non_resolus, Gêne =factor("Plutôt pas gênant",levels=gene_levels))


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)

# Créer un diagramme en barres empilées
p2 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Gêne)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Types de gênes par temps de cohabitation",
       x = "Temps de cohabitation",
       y = "Nombre de dysfonctionnements ") +
  scale_fill_manual(values = c("Très gênant" = "#1f77b4", 
                               "Plutôt gênant" = "#6baed6", 
                               "Plutôt pas gênant" = "#c6dbef")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="#1f77b4"),
        axis.title.x = element_text( face = "bold",colour="#1f77b4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="#1f77b4")) 

p2_interactif <- ggplotly(p2)

# Afficher le graphique interactif
p2_interactif 
```

```{r echo=FALSE}
p1_interactif <- ggplotly(p1)
p2_interactif <- ggplotly(p2) 

# Utiliser subplot pour afficher les graphiques côte à côte
subplot(
  p2_interactif, p1_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Types de gênes ressenties par temps de cohabitation",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")
    ),
    annotations = list(
      list(
        x = 0.2, y = 1.05, text = "Sur 316 dysfonctionnements", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "#1f77b4", family = "Arial", weight = "bold")
      ),
      list(
        x = 0.8, y = 1.05, text = "Sur le même niveau", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "#1f77b4", family = "Arial", weight = "bold")
      )
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1))  # Ajout de marge pour les titres
  )

```

Le premier graphe présente les degrés de gêne pour chaque temps de
cohabitation pour 316 dysfonctionnements, et le deuxième graphe met tous
ces temps de cohabitation au même niveau et représente la part de
chaque degré de gêne.

### **II ) Graphes qui rassemble les temps cohabitations pour tous les types de résolutions**

Le graphe suivant combine deux graphes indiquant le temps de
cohabitation pour ceux qui ont résolu, ceux qui ont tenté de résoudre et
qui n'ont pas réussi et ceux qui n'ont pas tenté de résoudre le dysfonctionnement :

```{r include=FALSE}
# Cohabitation + réparation 

REPARATION <- c(1:5)
matrice <- matrix(0,nrow=7,ncol=length(REPARATION))
matrice[1,] <- REPARATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
for (i in 81:105){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_REP <- df[j,i]
      num_COHAB <- df[j,i+25]
      if (!is.na(num_COHAB) && !is.na(num_REP) ){
        matrice[num_COHAB+1,num_REP]=matrice[num_COHAB+1,num_REP]+ df[j,"poids"]
      }
    }
}
print(matrice)

matrice_fin=matrice[2:nrow(matrice),1:3]
total=as.matrix(table(COHAB_non_resolus))

matrice_fin[2:5,3]=total[,1]
matrice_fin=t(matrice_fin)
print(matrice_fin)


normalize <- function(x) {
  return(round(x*100/colSums(matrice_fin)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat <- t(apply(t(matrice_fin), 2, normalize))
print(normalized_mat)

```



```{r include=FALSE}
Categorie <- factor(label_COHABITATION, levels = label_COHABITATION)
resolution_label <- c("Pas résolu","Tenté mais pas réussi","Résolu")

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[1,], Résolution = factor("Résolu",levels=resolution_label))
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[2,], Résolution = factor("Tenté mais pas réussi",levels=resolution_label))
df_T3 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[3,], Résolution = factor("Pas résolu",levels=resolution_label))


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)

# Créer un diagramme en barres empilées
p3 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Résolution)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Répartition des temps de Cohabitation",
       x = "Temps de cohabitation",
       y = " Pourcentage de problèmes ") +
  scale_fill_manual(values = c("Résolu" = "#33a02c", 
                               "Tenté mais pas réussi"= "#FFD700", 
                               "Pas résolu"= "#e31a1c")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold")) 

p3_interactif <- ggplotly(p3)

# Afficher le graphique interactif
p3_interactif  

```




```{r include=FALSE}
pbs= Count_VCM(data$RIDENTIFICATION_PROBLEMES,26)
nb_total_pbs <- sum(matrice_fin)

Categorie <- factor(label_COHABITATION, levels = label_COHABITATION)

resolution_label <- c("Pas résolu","Tenté mais pas réussi","Résolu")

df_T1 <- data.frame(Categorie = Categorie, valeurs = round(matrice_fin[1,]), Résolution = factor("Résolu",levels=resolution_label))
df_T2 <- data.frame(Categorie = Categorie, valeurs = round(matrice_fin[2,]), Résolution = factor("Tenté mais pas réussi",levels=resolution_label))
df_T3 <- data.frame(Categorie = Categorie, valeurs = round(matrice_fin[3,]), Résolution = factor("Pas résolu",levels=resolution_label))


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)

# Créer un diagramme en barres empilées
p4 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Résolution)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Répartition des temps de Cohabitation",
       x = "Temps de cohabitation",
       y = "Nombre de problèmes ") +
  scale_fill_manual(values = c("Résolu" = "#33a02c", 
                               "Tenté mais pas réussi"= "#FFD700", 
                               "Pas résolu"= "#e31a1c")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold")) 

p4_interactif <- ggplotly(p4)

# Afficher le graphique interactif
p4_interactif  
```

```{r}
df <- df_combined %>% 
  arrange( Categorie,Résolution)

df
```



```{r echo=FALSE}

# Utiliser subplot pour afficher les graphiques côte à côte
subplot(
  p4_interactif, p3_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Répartition des temps de cohabitation",
      font = list(size = 25, color = "black", family = "Arial", face = "bold")
    ),
    annotations = list(
      list(
        x = 0.2, y = 1.05, text = "Sur 667 dysfonctionnements", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "black", family = "Arial", weight = "bold")
      ),
      list(
        x = 0.8, y = 1.05, text = "Sur le même niveau", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "black", family = "Arial", weight = "bold")
      )
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1))  # Ajout de marge pour les titres
  )
```

Le premier graphe présente les types de résolution pour chaque temps de
cohabitation, et le deuxième graphe met tous ces temps de cohabitation au même niveau et représente la part de chaque type de résolution.

### **III ) Niveau de gêne de ceux qui ont réparé vs ceux qui n'ont pas réparé**

Le graphe suivant combine deux graphes indiquant le degré de gêne
ressenti pour ceux qui ont résolu, ceux qui ont tenté de résoudre et qui
n'ont pas réussi, et ceux qui n'ont pas tenté de résoudre les dysfonctionnements :

```{r include=FALSE}
gene_pbs_non_resolus=as.matrix(table(gene))
gene_pbs_non_resolus
```

```{r include=FALSE}
gene_tente_pas_reussi <- c()
gene_pbs_resolus <- c()

# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105 (indice des colonnes reparation)
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 1)) {
      g <- df[j, i - 50]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(g)) {
        gene_pbs_resolus <- c(gene_pbs_resolus,g)
      }
    }
    if (!is.na(val) && (val == 2)) {
      g <- df[j, i - 50]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(g)) {
        gene_tente_pas_reussi <- c(gene_tente_pas_reussi,g)
      }
    }
  }
}

gene_pbs_resolus=as.matrix(table(gene_pbs_resolus))
gene_tente_pas_reussi=as.matrix(table(gene_tente_pas_reussi))

print(gene_pbs_resolus)
print(gene_tente_pas_reussi)
```

```{r include=FALSE}
# Types de résolution en abscisse et gêne en ordonné

mat=matrix(0,nrow=3,ncol=3)
mat[,1]=gene_pbs_resolus[,1]
mat[,2]=gene_tente_pas_reussi[,1]
mat[,3]=gene_pbs_non_resolus[,1]
print(mat)
print(sum(mat))

total=colSums(mat)
print(total)

normalize <- function(x) {
  return(round(x*100/total))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat <- t(apply(mat, 1, normalize))
print(normalized_mat)
```

```{r include=FALSE}
label=c("Résolu","Tenté mais pas réussi","Pas résolu")
Categorie <- factor(label, levels = label)

gene_levels <- c("Plutôt pas gênant", "Plutôt gênant", "Très gênant")


df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[1,], Gêne = factor("Très gênant",levels=gene_levels))
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[2,], Gêne =factor("Plutôt gênant",levels=gene_levels))
df_T3 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[3,], Gêne = factor("Plutôt pas gênant",levels=gene_levels))


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)

# Créer un diagramme en barres empilées
p5 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Gêne)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Niveau de gêne en fonction de la résolution",
       x = "Type de résolution",
       y = "Pourcentage de dysfonctionnements ")  +
  scale_fill_brewer(palette = "Greens", name = "Degrés de Gêne") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="palegreen3"),
        axis.title.x = element_text( face = "bold",colour="palegreen3"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="palegreen3")) 

p5_interactif <- ggplotly(p5)

# Afficher le graphique interactif
p5_interactif  
```

```{r include=FALSE}
label=c("Résolu","Tenté mais pas réussi","Pas résolu")
Categorie <- factor(label, levels = label)

gene_levels <- c("Plutôt pas gênant", "Plutôt gênant", "Très gênant")

df_T1 <- data.frame(Categorie = Categorie, valeurs = mat[1,], Gêne = factor("Très gênant",levels=gene_levels))
df_T2 <- data.frame(Categorie = Categorie, valeurs = mat[2,], Gêne = factor("Plutôt gênant",levels=gene_levels))
df_T3 <- data.frame(Categorie = Categorie, valeurs = mat[3,], Gêne = factor("Plutôt pas gênant",levels=gene_levels))


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)

# Créer un diagramme en barres empilées
p6 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Gêne)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Niveau de gêne en fonction de la résolution",
       x = "Type de résolution",
       y = "Nombre de dysfonctionnements ")  +
  scale_fill_brewer(palette = "Greens", name = "Degrés de Gêne") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="palegreen3"),
        axis.title.x = element_text( face = "bold",colour="palegreen3"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="palegreen3")) 

p6_interactif <- ggplotly(p6)

# Afficher le graphique interactif
```

```{r echo=FALSE}

# Utiliser subplot pour afficher les graphiques côte à côte
subplot(
  p6_interactif, p5_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Degrés de gêne en fonction de la résolution ",
      font = list(size = 25, color = "black", family = "Arial", face = "bold")
    ),
    annotations = list(
      list(
        x = 0.2, y = 1.05, text = "Sur 667 dysfonctionnements", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "#33a02c", family = "Arial", weight = "bold")
      ),
      list(
        x = 0.8, y = 1.05, text = "Sur le même niveau", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "#33a02c", family = "Arial", weight = "bold")
      )
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1))  # Ajout de marge pour les titres
  )
```

Le premier graphe présente les degrés de gêne pour chaque temps de
résolution, et le deuxième graphe met tous ces types de résolution au même niveau et représente la part de chaque degré de gêne.

### **IV ) Quels usages du smarthpone sont impactés par les dysfonctionnements ?** 

Ici il n'a été concidéré que les personnes qui avait rencontrés **un
dysfonctionnement** (187 personnes), et qui avaient par la suite listé les
impacts que ce dysfonctionnement avait sur leur smartphone, ce qui a
donnée le graphe suivant :

```{r include=FALSE}
matrice = matrix(0,nrow=15,ncol=25)

n= 0

df = data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
variable=df$RIDENTIFICATION_PROBLEMES

for (i in 1:length(variable)){
  liste_pbs=str_extract_all(variable[i], ".{2}")[[1]]
  if (length(liste_pbs)==1){
    n=n+1
    for (j in 1:length(liste_pbs)){
      pb=liste_pbs[1]
      pb=as.numeric(pb)
      liste_impacts = str_extract_all(df[i,"RIMPACT_PB"], ".{2}")[[1]]
      liste_impacts = as.numeric(liste_impacts)
      for (k in liste_impacts){
        matrice[k,pb]=matrice[k,pb]+1
      }
    }
  }
}

print(matrice)
print(n) # 187
```

```{r echo=FALSE}
# Créer une palette de 25 couleurs distinctes
distinct_colors <- c("#1f78b4", "#33a02c", "#e31a1c", "#ff7f00", "#6a3d9a", 
                     "#b15928", "#a6cee3", "#b2df8a", "#fb9a99", "#fdbf6f",
                     "#cab2d6", "#ffff99", "#8dd3c7", "#ffffb3", "#bebada", 
                     "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", 
                     "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#66c2a5")

Categorie <- factor(label_RIDENTIFICATION_PROBLEME[1:25], levels = label_RIDENTIFICATION_PROBLEME[1:25])

df_combined <- data.frame(Categorie = Categorie, valeurs = matrice[1,], Impact =label_IMPACT[1])

for (i in 2:nrow(matrice)){
  df_T1 <- data.frame(Categorie = Categorie, valeurs = matrice[i,], Impact =label_IMPACT[i])
  df_combined <- rbind(df_combined, df_T1)
}

p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Impact)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Usages impactés par les dysfonctionnements ",
       x = "Dysfonctionnements",
       y = "Nombre de personnes") +
  scale_fill_manual(values = distinct_colors, name = "Impact") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", colour = "turquoise4"),
        axis.title.x = element_text(face = "bold", colour = "turquoise4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold", colour = "turquoise4"))

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif


```

La lecture des informations n'étant pas trés lisible, les représentations
qui suivent montrent pour 5 dysfonctionnements, les usages impactés :

```{r include=FALSE}
# Création de la variable Categorie comme facteur
distinct_colors <- c("#1f78b4", "#33a02c", "#e31a1c", "#ff7f00", "#6a3d9a", 
                     "#b15928", "#a6cee3", "#b2df8a", "#fb9a99", "#fdbf6f",
                     "#cab2d6", "#ffff99", "#8dd3c7", "#ffffb3", "#bebada", 
                     "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", 
                     "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#66c2a5")

Categorie <- factor(label_RIDENTIFICATION_PROBLEME[1:5], levels = label_RIDENTIFICATION_PROBLEME[1:5])

# Création du dataframe combiné
df_combined <- data.frame(Categorie = Categorie, valeurs = matrice[1,1:5], Impact = label_IMPACT[1])

for (i in 1:nrow(matrice)) {
  df_T1 <- data.frame(Categorie = Categorie, valeurs = matrice[i,1:5], Impact = label_IMPACT[i])
  df_combined <- rbind(df_combined, df_T1)
}

# Génération du graphique
p1 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = as.factor(Impact))) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Usages impactés par les dysfonctionnements",
       x = "",
       y = "Nombre de personnes ")  +
 scale_fill_manual(values = distinct_colors, name = "Impact") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", colour = "turquoise4"),
        axis.title.x = element_text(face = "bold", colour = "turquoise4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold", colour = "turquoise4"))

# Conversion du graphique en graphique interactif
p1_interactif <- ggplotly(p1)

# Affichage du graphique interactif
p1_interactif

```

```{r include=FALSE}
distinct_colors <- c("#1f78b4", "#33a02c", "#e31a1c", "#ff7f00", "#6a3d9a", 
                     "#b15928", "#a6cee3", "#b2df8a", "#fb9a99", "#fdbf6f",
                     "#cab2d6", "#ffff99", "#8dd3c7", "#ffffb3", "#bebada", 
                     "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", 
                     "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#66c2a5")


Categorie <- factor(label_RIDENTIFICATION_PROBLEME[6:11], levels = label_RIDENTIFICATION_PROBLEME[6:11])

# Création du dataframe combiné
df_combined <- data.frame(Categorie = Categorie, valeurs = matrice[1,6:11], Impact = label_IMPACT[1])

for (i in 1:nrow(matrice)) {
  df_T1 <- data.frame(Categorie = Categorie, valeurs = matrice[i,6:11], Impact = label_IMPACT[i])
  df_combined <- rbind(df_combined, df_T1)
}

# Génération du graphique
p2 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = as.factor(Impact))) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Usages impactés par les dysfonctionnements ",
       x = "",
       y = " ")  +
 scale_fill_manual(values = distinct_colors, name = "Impact") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", colour = "turquoise4"),
        axis.title.x = element_text(face = "bold", colour = "turquoise4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold", colour = "turquoise4"))

# Conversion du graphique en graphique interactif
p2_interactif <- ggplotly(p2)

# Affichage du graphique interactif
p2_interactif
```

```{r include=FALSE}
distinct_colors <- c("#1f78b4", "#33a02c", "#e31a1c", "#ff7f00", "#6a3d9a", 
                     "#b15928", "#a6cee3", "#b2df8a", "#fb9a99", "#fdbf6f",
                     "#cab0d6", "#ffff99", "#8dd3c7", "#ffffb3", "#bebada", 
                     "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", 
                     "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#66c2a5")

Categorie <- factor(label_RIDENTIFICATION_PROBLEME[12:17], levels = label_RIDENTIFICATION_PROBLEME[12:17])

# Création du dataframe combiné
df_combined <- data.frame(Categorie = Categorie, valeurs = matrice[1,12:17], Impact = label_IMPACT[1])

for (i in 1:nrow(matrice)) {
  df_T1 <- data.frame(Categorie = Categorie, valeurs = matrice[i,12:17], Impact = label_IMPACT[i])
  df_combined <- rbind(df_combined, df_T1)
}

# Génération du graphique
p3 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = as.factor(Impact))) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Usages impactés par les dysfonctionnements ",
       x = "",
       y = "Nombre de personnes ")  +
 scale_fill_manual(values = distinct_colors, name = "Impact") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", colour = "turquoise4"),
        axis.title.x = element_text(face = "bold", colour = "turquoise4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold", colour = "turquoise4"))

# Conversion du graphique en graphique interactif
p3_interactif <- ggplotly(p3)

# Affichage du graphique interactif
p3_interactif
```

```{r include=FALSE}
distinct_colors <- c("#1f78b4", "#33a02c", "#e31a1c", "#ff7f00", "#6a3d9a", 
                     "#b15928", "#a6cee3", "#b2df8a", "#fb9a99", "#fdbf6f",
                     "#cab2d6", "#ffff99", "#8dd3c7", "#ffffb3", "#bebada", 
                     "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", 
                     "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#66c2a5")

Categorie <- factor(label_RIDENTIFICATION_PROBLEME[18:23], levels = label_RIDENTIFICATION_PROBLEME[18:23])

# Création du dataframe combiné
df_combined <- data.frame(Categorie = Categorie, valeurs = matrice[1,18:23], Impact = label_IMPACT[1])

for (i in 1:nrow(matrice)) {
  df_T1 <- data.frame(Categorie = Categorie, valeurs = matrice[i,18:23], Impact = label_IMPACT[i])
  df_combined <- rbind(df_combined, df_T1)
}

# Génération du graphique
p4 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = as.factor(Impact))) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Usages impactés par les dysfonctionnements" ,
       x = "",
       y = " ")  +
 scale_fill_manual(values = distinct_colors, name = "Impact") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", colour = "turquoise4"),
        axis.title.x = element_text(face = "bold", colour = "turquoise4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold", colour = "turquoise4"))

# Conversion du graphique en graphique interactif
p4_interactif <- ggplotly(p4)

# Affichage du graphique interactif
p4_interactif
```

```{r include=FALSE}
distinct_colors <- c("#1f78b4", "#33a02c", "#e31a1c", "#ff7f00", "#6a3d9a", 
                     "#b15928", "#a6cee3", "#b2df8a", "#fb9a99", "#fdbf6f",
                     "#cab2d6", "#ffff99", "#8dd3c7", "#ffffb3", "#bebada", 
                     "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", 
                     "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#66c2a5")

Categorie <- factor(label_RIDENTIFICATION_PROBLEME[24:25], levels = label_RIDENTIFICATION_PROBLEME[24:25])

# Création du dataframe combiné
df_combined <- data.frame(Categorie = Categorie, valeurs = matrice[1,24:25], Impact = label_IMPACT[1])

for (i in 1:nrow(matrice)) {
  df_T1 <- data.frame(Categorie = Categorie, valeurs = matrice[i,24:25], Impact = label_IMPACT[i])
  df_combined <- rbind(df_combined, df_T1)
}

# Génération du graphique
p5 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = as.factor(Impact))) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Usages impactés par les dysfonctionnements ",
       x = "",
       y = "Nombre de personnes ")  +
 scale_fill_manual(values = distinct_colors, name = "Impact") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, colour = "turquoise4"),
        axis.title.x = element_text(face = "bold", colour = "turquoise4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold", colour = "turquoise4"))

# Conversion du graphique en graphique interactif
p5_interactif <- ggplotly(p5)

# Affichage du graphique interactif
p5_interactif
```

```{r echo=FALSE}
p1_interactif
```

```{r echo=FALSE}
p2_interactif
```

```{r echo=FALSE}
p3_interactif
```

```{r echo=FALSE}
p4_interactif
```

```{r echo=FALSE}
p5_interactif
```

### **V ) Répartition des dysfonctionnements :**

La répartition des dysfonctionnements s'est faite selon la
catégorisation suivante :

-   **Problème de stockage :** Stockage saturé

-   **Problème matériel :** Problème avec l'écran, Problème de
    sensibilité du tactile, Problème avec l'appareil photo Problème de
    vibreur, Problème de capteurs, Problème de batterie, Problème de
    chargement, Problème de prise jack Problème de son, Problème avec le
    micro, Problème avec la lampe torche ou le flash, Problème avec les
    boutons

-   **Problème de mise à jour :** Système d'exploitation non mis à jour,
    Applications ne pouvant pas être téléchargées ou mises à jour

-   **Dysfonctionnement divers :** Problème lié à une fonctionnalité
    manquante, Fonctionnalité qui ne marche plus, Dysfonctionnement
    logiciel, Problèmes avec des applications, Problème d'accès à
    Internet, Problème de téléphonie, Problème de Bluetooth ou de
    transferts de fichiers sans fil, Problème de Wi-Fi, Problème avec le
    GPS, Problème de lenteur

La représentation graphique qui suit permet de visualiser cette
répartition :

```{r include=FALSE}
label_dys <- c("Stockage","Matériel","Mise à jour","Dys divers")

materiel <- c(1,2,1,3,4,6,7,8,9,10,12,16,17)
dys_divers <- c(5,11,13,14,15,21,22,23,24,25)
stockage <- c(18)
maj <- c(19,20)

# Trouver la liste qui contient le plus d'éléments pour après définir le nombre de colonnes de notre matrice
max_length <- max(length(materiel), length(dys_divers), length(stockage), length(maj))

# Initialiser la matrice avec des zéros
matrice_cat <- matrix(0, nrow = 4, ncol = max_length)

# Remplir les lignes de la matrice avec les listes
matrice_cat[1, 1:length(stockage)] <- stockage
matrice_cat[2, 1:length(materiel)] <- materiel
matrice_cat[3, 1:length(maj)] <- maj
matrice_cat[4, 1:length(dys_divers)] <- dys_divers

# Afficher la matrice
print(matrice_cat)
```


```{r include=FALSE}
variable=data$RIDENTIFICATION_PROBLEMES
nb_de_modalites = 25
valeurs = Count_VCM(variable,nb_de_modalites)

num_pb = c()
nb_pb = c()
cat_pb = c()

valeurs = Count_VCM(variable,nb_de_modalites)

for (i in 1:ncol(valeurs)){
  num_pb=c(num_pb,valeurs[1,i])
  nb_pb = c(nb_pb,valeurs[2,i])
  
  result <- which(matrice_cat == i, arr.ind = TRUE)
  cat <- result[1]
  
  cat_pb=c(cat_pb,cat)
}

dataframe = data.frame(Dys = num_pb, nb = round(nb_pb), Categorie = cat_pb)

dataframe <- dataframe %>% 
  arrange( Categorie,desc(nb))

dataframe$Dys = factor(dataframe$Dys, levels=1:length(label_RIDENTIFICATION_PROBLEME),labels=label_RIDENTIFICATION_PROBLEME)

dataframe$Categorie= factor(dataframe$Categorie, levels = 1:length(label_dys),labels=label_dys)

dataframe

nrow(dataframe[which(dataframe$Categorie==1),]) # 1
nrow(dataframe[which(dataframe$Categorie==2),]) # 12
nrow(dataframe[which(dataframe$Categorie==3),]) # 2
nrow(dataframe[which(dataframe$Categorie==4),]) # 10 

```

```{r echo=FALSE}

label <- c("Stockage saturé","Problème de batterie","Problème avec l’écran","Problème de sensibilité du tactile","Problème de chargement","Problème de son","Problème avec le micro","Problème avec l’appareil photo","Problème avec les boutons","Problème de prise jack","Problème avec la lampe torche ou le flash","Problème de capteurs","Problème de vibreur","Applications ne pouvant pas être téléchargées ou mises à jour","Système d’exploitation non mis à jour","Problème de lenteur","Problèmes avec des applications","Problème de Wi-Fi","Dysfonctionnement logiciel","Problème lié à une fonctionnalité manquante","Problème de téléphonie","Problème d’accès à Internet","Fonctionnalité qui ne marche plus","Problème avec le GPS","Problème de Bluetooth ou de transferts de fichiers sans fil")

dataframe$Dys = factor(dataframe$Dys,levels=label)

p <- ggplot(dataframe, aes(x = Categorie, y = nb, fill =Dys)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("Stockage saturé"= "#1E90FF","Problème de batterie"= "#004d00","Problème avec l’écran"="#006600","Problème de sensibilité du tactile"="#007f00","Problème de chargement"="#009900","Problème de son"="#00b300","Problème avec le micro"="#00cc00","Problème avec l’appareil photo"="#00e600","Problème avec les boutons"="#1aff1a","Problème de prise jack"="#4dff4d","Problème avec la lampe torche ou le flash"="#80ff80","Problème de capteurs"="#b3ffb3","Problème de vibreur"="#e6ffe6","Applications ne pouvant pas être téléchargées ou mises à jour"="#FFD700","Système d’exploitation non mis à jour"="#FFFF00","Problème de lenteur"="#4B0082","Problèmes avec des applications"="#6A0DAD","Problème de Wi-Fi"="#7B1FA2","Dysfonctionnement logiciel"="#8E24AA","Problème lié à une fonctionnalité manquante"="#9C27B0","Problème de téléphonie"="#AB47BC","Problème d’accès à Internet"="#BA68C8","Fonctionnalité qui ne marche plus"="#CE93D8","Problème avec le GPS"="#E1BEE7","Problème de Bluetooth ou de transferts de fichiers sans fil"="#F3E5F5")) +
  labs(title = "Répartition des dysfonctionnements",
       x = "Catégorie",
       y = "Nombre de dysfonctionnements",
       fill = "Problème") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text(face = "bold"), 
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

# Affichage du graphique
p_interactif <- ggplotly(p)

# Affichage du graphique interactif
p_interactif
```


### **VI ) Graphes représentant les temps de cohabitation en fonction de la catégorie de dysfonctionnement et du degrés de gêne** 


```{r include=FALSE}
### Création d'un dataframe avec 4 colonnes : le numéro du dys, la catégorie du dys, le degre de gêne du dys et le temps de cohabitation du dys :

# dys qui ont tenté d'être résoud ou qui ont été résolus

pbs = c()
cate_dys = c()
deg_gene = c()
cohab = c()

df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27" & data$RIDENTIFICATION_PROBLEMES != "26"),]
variable = df$RIDENTIFICATION_PROBLEMES

for (i in 1:length(variable)){
  liste_pbs =str_extract_all(variable[i], ".{2}")[[1]]
  liste_pbs = as.numeric(liste_pbs)
  for (j in 1:length(liste_pbs)){
    pb = liste_pbs[j]
    num=as.character(pb)
    g=paste0("GENE_PROBLEMES_A",num)
    gene=df[i,g]
    c= paste0("COHABITATION_DYSFONCTION_A",num)
    coha = df[i,c]
    if(!is.null(gene) && !is.na(gene) && !is.null(coha) && !is.na(coha)){
      
      result <- which(matrice_cat == pb, arr.ind = TRUE)
      cat <- result[1]
      pbs = c(pbs,pb)
      cate_dys = c(cate_dys,cat)
      deg_gene = c(deg_gene,gene)
      cohab = c(cohab,coha)
        }
  }
}

#print(head(pbs))
#print(head(cate_dys))
#print(head(deg_gene))
#print((head(cohab)))

print(length(pbs))
print(length(cate_dys))
print(length(deg_gene))
print(length(cohab))



don = data.frame()
don <- data.frame( "Categorie_dys"=cate_dys, "Gêne"=deg_gene,"Cohab"=cohab)
print(head(don))
print(nrow(don))
```

```{r include=FALSE}

# dys qui  n'ont pas été résolus

# Initialisation des vecteurs pour stocker les valeurs de recence, année, et mois
recence <- c()
annee <- c()
mois <- c()
gene <- c()
pbs = c()
cate_dys = c()


# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105 (indice des colonnes reparation)
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 4 || val == 5)) {
      RECENCE <- df[j, i - 25]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(RECENCE)) {
        recence <- c(recence, RECENCE)
        annee <- c(annee, df[j, "DATEOBTENTIONSMART_1"])
        mois <- c(mois, df[j, "DATEOBTENTIONSMART_2"])
        gene <- c(gene,df[j, i - 50])
        result <- which(matrice_cat == (i-80), arr.ind = TRUE)
        cat <- result[1]
        pbs = c(pbs,i-80)
        cate_dys = c(cate_dys,cat)
      }
    }
  }
}

# Suppression de la raison 7 dans la liste recence 

indices_rec_7= which(recence==7)
gene=gene[-c(indices_rec_7)]
pbs=pbs[-c(indices_rec_7)]
cate_dys=cate_dys[-c(indices_rec_7)]

don2 <- data.frame( "Categorie_dys"=cate_dys, "Gêne"=gene,"Cohab"=COHAB_non_resolus)

# Afficher les résultats pour vérifier
print(head(pbs))
print(head(cate_dys))
print(head(gene))

# Jointure des dataframe entre eux 
don <- rbind(don,don2)

# Création d'un autre dataframe pour une future jointure 
don1 <- rbind(don,don2)

head(don)
nrow(don)
nrow(don2)
```

```{r include=FALSE}
# calcul du nombre de personnes pour les différents cas possibles

liste = c()
for (k in 1:nrow(don)){
  i = don[k,"Gêne"]
  j = don[k,"Categorie_dys"]
  l = don[k,"Cohab"]
  df2 <- don[which(don$Categorie_dys==j & don$Gêne==i & don$Cohab==l),]
  nb = nrow(df2)
  liste = c(liste,nb)
  
}
don$nb <- liste
don <- unique(don)
don <- don %>% 
  arrange( Cohab,Gêne,Categorie_dys)

don$labels<- rep(c("Dys Stockage trés gênant","Dys Matériel trés gênant","Dys Maj trés gênant", "Dys divers trés gênant","Dys Stockage plutôt gênant", "Dys Matériel plutôt gênant","Dys Maj plutôt gênant","Dys divers plutôt gênant","Dys Stockage plutôt pas gênant", "Dys Matériel plutôt pas gênant","Dys Maj plutôt pas gênant","Dys divers plutôt pas gênant"),times=5)

print(don)
nrow(don)
```

Le graphe suivant présente pour chaque temps de cohabitation la part de
chaque degré de gêne, et dans ces parts, la part de chaque catégorie de
dysfonctionnements :

```{r echo=FALSE}
# Création du graphique à barres empilées
p <- ggplot(don, aes(x = factor(Cohab, levels = 1:length(label_COHABITATION),labels=label_COHABITATION), y = nb, fill = factor(labels, levels = unique(labels)))) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("Dys Stockage trés gênant"="#006400","Dys Matériel trés gênant"= "#228B22","Dys Maj trés gênant"= "#32CD32", "Dys divers trés gênant"="#98FB98","Dys Stockage plutôt gênant"="#FFD700", "Dys Matériel plutôt gênant"="#FFF200","Dys Maj plutôt gênant"= "#FFFF00","Dys divers plutôt gênant"= "#FFFFE0","Dys Stockage plutôt pas gênant"= "#000080", "Dys Matériel plutôt pas gênant"="#0000CD","Dys Maj plutôt pas gênant"= "#1E90FF","Dys divers plutôt pas gênant"= "#ADD8E6")) +
  labs(title = "Degrés de gêne et dysfonctionnements par temps de cohabitation",
       x = "Temps de Cohabitation",
       y = "Nombre de dysfonctionnements",
       fill = "Catégorie et Gêne") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text(face = "bold"), 
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

# Affichage du graphique
p_interactif <- ggplotly(p)

# Affichage du graphique interactif
p_interactif
```

```{r include=FALSE}

labels <- c("Dys Stockage trés gênant","Dys Stockage plutôt gênant","Dys Stockage plutôt pas gênant", "Dys divers trés gênant", "Dys Divers plutôt gênant","Dys Divers plutôt pas gênant","Dys Maj trés gênant", "Dys Maj plutôt gênant","Dys Maj plutôt pas gênant","Dys Matériel trés gênant", "Dys Matériel plutôt gênant","Dys Matériel plutôt pas gênant")

colors <- c("Dys Stockage trés gênant"="#006400","Dys Stockage plutôt gênant"= "#228B22","Dys Stockage plutôt pas gênant"= "#98FB98", "Dys divers trés gênant"="#FFD700", "Dys Divers plutôt gênant"="#FFF200","Dys Divers plutôt pas gênant"= "#FFFFE0","Dys Maj trés gênant"= "#0000CD", "Dys Maj plutôt gênant"="#1E90FF","Dys Maj plutôt pas gênant"= "#ADD8E6","Dys Matériel trés gênant"= "#B22222", "Dys Matériel plutôt gênant"="#FF0000","Dys Matériel plutôt pas gênant"= "#FFA07A")


liste = c()
for (k in 1:nrow(don1)){
  i = don1[k,"Gêne"]
  j = don1[k,"Categorie_dys"]
  l = don1[k,"Cohab"]
  df2 <- don1[which(don1$Categorie_dys==j & don1$Gêne==i & don1$Cohab==l),]
  nb = nrow(df2)
  liste = c(liste,nb)
  
}
don1$nb <- liste
don1 <- unique(don1)
don1 <- don1 %>% 
  arrange( Cohab,Categorie_dys,Gêne)

don1$labels<- rep(labels,times=5)

print(don1)
nrow(don1)
```

Le graphe suivant présente pour chaque temps de cohabitation la part de
chaque catégorie de dysfonctionnments, et dans ces parts, la part de
chaque degrés de gêne :

```{r echo=FALSE}

# Création du graphique à barres empilées
p <- ggplot(don1, aes(x = factor(Cohab, levels = 1:length(label_COHABITATION),labels=label_COHABITATION), y = nb, fill = factor(labels, levels = unique(labels)))) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values =c("Dys Stockage trés gênant"="#006400","Dys Stockage plutôt gênant"= "#228B22","Dys Stockage plutôt pas gênant"= "#98FB98", "Dys divers trés gênant"="#FFD700", "Dys Divers plutôt gênant"="#FFF200","Dys Divers plutôt pas gênant"= "#FFFFE0","Dys Maj trés gênant"= "#0000CD", "Dys Maj plutôt gênant"="#1E90FF","Dys Maj plutôt pas gênant"= "#ADD8E6","Dys Matériel trés gênant"= "#B22222", "Dys Matériel plutôt gênant"="#FF0000","Dys Matériel plutôt pas gênant"= "#FFA07A")) +
  labs(title = "Degrés de gêne et dysfonctionnements par temps de cohabitation",
       x = "Temps de Cohabitation",
       y = "Nombre de dysfonctionnements",
       fill = "Catégorie et Gêne") +
  theme_minimal() +
  coord_flip()+
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text(face = "bold"), 
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

# Affichage du graphique
p_interactif <- ggplotly(p)

# Affichage du graphique interactif
p_interactif
```

```{r include=FALSE}
indice_colonne <- which(names(data) == "GENE_PROBLEMES_A1")
print(indice_colonne) # 106

indice_colonne <- which(names(data) == "REPARATION_A1")
print(indice_colonne) # 81

indice_colonne <- which(names(data) == "GENE_PROBLEMES_A25")
print(indice_colonne) # 80

indice_colonne <- which(names(data) == "REPARATION_A25")
print(indice_colonne) #105

81-31

```
