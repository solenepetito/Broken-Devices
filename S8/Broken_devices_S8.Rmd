---
title: 'Project : Broken devices S8'
author: "Solène PETITO"
output:
  html_document: default
  pdf_document: default
  word_document: default
date: "2024-07-22"
editor_options: 
  markdown: 
    wrap: 72
---

# **SEMAINE DU 15 JUILLET 2024 au 20 JUILLET 2024 :**

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
############### MODULE 1 : Chargement des librairies

library(openxlsx)
library(readxl)
library(ggplot2)
library(stringr)
library(tibble)
library(dplyr)
library(plotly) # permet de faire des graphes intéractifs
library(corrplot) # permet de réqliser des matrices de corrélation
library(tidyr)
library(RColorBrewer) # librairie pour les palettes de couleurs
library(viridis) # palette de couleurs > 25 nuances
library(Polychrome)
library(gridExtra) # afficher les graphes côte à côte
library(grid)

```

```{r include=FALSE}
############### MODULE 2 : Création de fonctions

# fonction func1 qui prend en entrée un jeu de données (don) et le nom d'une colonne de type Cri (Caratère répétitive) de ce jeu de données (colonne), sous forme de chaine de caractères et sans préciser de numéro à la fin de celle-ci  : ex : "COHABITATION_DYSFONCTION_A" ou "GENE_PROBLEMES_A". Elle renvoit en sortie une matrice a 2 lignes et 25 colonnes, indiquant en ligne 1 le type de dysfonctionnement, et en ligne 2 une modalité moyenne calculée pour la variable donnée en entrée pour chaque type de dysfonctionnements.

func1 <- function (don,colonne){
  matrice <- matrix(0,nrow=2,ncol=25)
  matrice[1,] <- c(1:25)
  df = don[which(don$RIDENTIFICATION_PROBLEMES!="27"),]
  variable=df$RIDENTIFICATION_PROBLEMES
  for (pb in 1:25){
    vec=c()
    for (i in 1:length(variable)){
      ligne=str_extract_all(variable[i], ".{2}")[[1]]
      ligne=sub("^0+", "", ligne)
      if (pb %in% ligne){
        num=as.character(pb)
        nom_colonne=paste0(colonne,num)
        valeur=df[i,nom_colonne]
        if(!is.null(valeur) && !is.na(valeur)){
          vec=c(vec,valeur)
        }
      }
    }
    if (length(vec) > 0) {
    matrice[2, pb] <- round(mean(vec))
  } else {
    matrice[2, pb] <- 0
  }
  }
  return(matrice)
}
##########################################

# Création d'une fonction **Count_VCM** (VCM = Variable à choix multiples) permettant d'afficher pour les variables à choix multiples UNIQUEMENT, le nombre de fois où chaque modalité est renseignée dans toute la colonne. Elle prend en entrée une variable à choix multiple (*variable*), issue de la base de données, et son nombre total de modalités (*nb_de_modalites*), et renvoit une matrice indiquant en ligne 1 le numéro de la modalité, et en ligne 2 le nombre de fois où les répondants l'on choisit.

Count_VCM <- function(variable,nb_de_modalites){
  mat <- matrix(0,nrow=2,ncol=nb_de_modalites)
  mat[1,]=c(1:nb_de_modalites)
  for (i in 1:length(variable)){
    ligne=str_extract_all(variable[i],".{2}")[[1]]
    vec=sub("^0+","",ligne)
    for (j in 1:length(vec)){
      for (k in 1:ncol(mat)){
        if (vec[j]==mat[1,k]){
          mat[2,k]=mat[2,k]+ 1 # mettre "+1" à la place de "data[i,"poids"]" si on ne concidère pas les poids
        }
      }
    }
  }
  return(mat)
}

##########################################

# Pour éviter d'avoir à afficher les numéros des modalités sur chaques graphes, je stocke directement les libellés des modalités dans des vecteurs

label_RIDENTIFICATION_PROBLEME = c("Problème avec l’écran","Problème de sensibilité du tactile","Problème avec l’appareil photo","Problème avec la lampe torche ou le flash","Problème avec le GPS","Problème avec le micro","Problème de son","Problème de prise jack","Problème de chargement","Problème de batterie","Problème de Wi-Fi","Problème de capteurs","Problème de Bluetooth ou de transferts de fichiers sans fil","Problème de téléphonie","Problème d’accès à Internet","Problème avec les boutons","Problème de vibreur","Stockage saturé","Système d’exploitation non mis à jour","Applications ne pouvant pas être téléchargées ou mises à jour","Problème lié à une fonctionnalité manquante","Fonctionnalité qui ne marche plus","Dysfonctionnement logiciel","Problèmes avec des applications","Problème de lenteur","Autre")

label_ACQUISITION = c("Quelqu’un me l’a offert ou donné","Quelqu’un me l’a prêté","Je l’ai acheté","Je l’ai obtenu dans le cadre de mon contrat avec mon opérateur","Mon employeur me l’a fourni","Je l’ai loué","Je ne me souviens pas","Obtenu par un autre moyen")

label_COHABITATION = c("Dès que j’ai décelé le dysfonctionnement","Moins d’un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de deux ans","Je ne sais pas" )

label_GENE=c("Très gênant","Plutôt gênant","Plutôt pas gênant","Pas gênant du tout")

label_INT_REPARATION= c("Oui, par moi-même","Oui, par le SAV ou un réparateur","Oui, par une connaissance","Pas pour l’instant", "Non")

label_RECENCE <- c("Dès la première utilisation","En moins de 3 mois","Entre 3 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Plus de 3 ans","Je ne sais pas")

label_REPARATION <- c("Oui et le problème est resolu","Oui mais le problème na pas pu être résolu","Non, le problème s’est résolu tout seul au bout d’un moment","Non, peut être plus tard","Non, je ne pense pas tenter de résoudre le problème")

label_OS <- c("IOS (Apple)","Android","Autre","Je ne sais pas")

label_ETAT= c("Neuf","D'occasion","Reconditionné","Je ne sais pas" )

label_COHAB_2 <- c("Moins d'un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de 2 ans")

label_RAISON_UTIL_PB <- c("Cela serait trop coûteux de résoudre le(s) problème(s) ou de remplacer mon smartphone",
"J’attends une opportunité", "Je ne peux pas résoudre le problème car le smartphone ne m’appartient pas","Je ne sais pas comment résoudre le(s) problème(s)","Je veux faire durer mon téléphone le plus longtemps possible","Ce(s) problème(s) ne m’impacte(nt) pas tant que ça au quotidien","Je n’ai pas pris le temps de m’en occuper, de chercher une solution","Mon téléphone est trop récent pour que je le fasse réparer ou que je le remplace","La résolution du (ou des) problème(s) est trop difficile ou incertaine","Ça me donne un prétexte pour moins l’utiliser","Cela ne vaut pas la peine de résoudre le(s) problème(s)","Mon smartphone a une particularité difficile à retrouver si je devais le remplacer","Autre")

label_IMPACT <- c("Usage global du smartphone","Communication ","Réseaux sociaux ","Cartes et guidage GPS","Jeux","Navigation web","Streaming musique et vidéo","Outils de productivité ","Logiciels et applications professionnelles dédiées","Photo, vidéo et autres activités de création","Identification bancaire, paiement sans contact","Tickets dématérialisés ","Courses et achats en ligne","Autre","Aucun")

label_dys <- c("Stockage","Matériel","Mise à jour","Dys divers")
```

```{r include=FALSE}
# Catégorisation des dysfonctionnements

label_dys <- c("Stockage","Matériel","Mise à jour","Dys divers")

materiel <- c(1,2,3,4,6,7,8,9,10,12,16,17)
dys_divers <- c(5,11,13,14,15,21,22,23,24,25)
stockage <- c(18)
maj <- c(19,20)

# Trouver la liste qui contient le plus d'éléments pour après définir le nombre de colonnes de notre matrice
max_length <- max(length(materiel), length(dys_divers), length(stockage), length(maj))

# Initialiser la matrice avec des zéros
matrice_cat <- matrix(0, nrow = 4, ncol = max_length)

# Remplir les lignes de la matrice avec les listes
matrice_cat[1, 1:length(stockage)] <- stockage
matrice_cat[2, 1:length(materiel)] <- materiel
matrice_cat[3, 1:length(maj)] <- maj
matrice_cat[4, 1:length(dys_divers)] <- dys_divers

# Afficher la matrice
print(matrice_cat)
```

**OBJECTIF :** *Analyser la base de données*

## **ANALYSE DE LA BASE DE DONNÉES**

```{r include=FALSE}
# Import des données

data <- readRDS("/home/solene_petito/Bureau/Stage/Broken_devices/data/data1.rds") # base de données sur laquelle on va appliquer tous les changements

# Exporter la base de données en format Excel
write.xlsx(data, file = "/home/solene_petito/Bureau/Stage/Broken_devices/data/database.xlsx")

Broken_Devices_Data <- read.csv("/home/solene_petito/Bureau/Stage/Broken_devices/data/Broken-Devices-Data1-xlsx.csv",row.names=1) # base de données initiale sur laquelle on pourra se référer pour voir si les chgts ont bien été appliqués

# nombre d'observations
nb_obs <- nrow(data) # 968 

# nombre de variables 
nb_var <- ncol(data) # 164
```

```{r include=FALSE}
View(data)
View(Broken_Devices_Data)
```

```{r include=FALSE}
REPARATION <- c(1:5)
matrice_REP=matrix(0,nrow=2,ncol=length(REPARATION))
matrice_REP[1,]=REPARATION

colonne_deb <- which(names(data) == "REPARATION_A1")
#print(colonne_deb) # 81

colonne_fin <- which(names(data) == "REPARATION_A25")
#print(colonne_fin) # 105

df <- data[,colonne_deb:colonne_fin]

for (i in 1 :ncol(df)){
    for (j in 1:nrow(df)){
      val=df[j,i]
      if(!is.na(val)&& !is.null(val)){
        matrice_REP[2,val]=matrice_REP[2,val]+1
      }
    }
  }
```

### **I ) Variable ETAT ANCIEN TEL**

**Question :** Dans quel état était votre ancien téléphone au moment où
il a été remplacé ?

Les réponses possibles étaient :

-   1 : Mon téléphone fonctionnait bien

-   2 : Mon téléphone fonctionnait mais il lui manquait une ou plusieurs
    fonctionnalités

-   3 : Mon téléphone était complètement inutilisable

-   4 : La durée de vie de la batterie était faible

-   5 : Le stockage de mon téléphone était insuffisant

-   6 : Mon téléphone était lent

-   7 : Mon téléphone était physiquement endommagé

-   8 : Mon téléphone avait des dysfonctionnements

-   9 : Autre raison

-   10 : Je ne me souviens pas

```{r include=FALSE}
variable=data[which(data$RETAT_ANCIEN_TEL!=""),"RETAT_ANCIEN_TEL"]
nb_de_modalites=10
matrice=Count_VCM(variable,nb_de_modalites)
matrice[2,]=round(matrice[2,])

labels= c("Mon téléphone fonctionnait bien","Mon téléphone fonctionnait mais il lui manquait une ou plusieurs fonctionnalités","Mon téléphone était complètement inutilisable","La durée de vie de la batterie était faible","Le stockage de mon téléphone était insuffisant","Mon téléphone était lent","Mon téléphone était physiquement endommagé","Mon téléphone avait des dysfonctionnements","Autre raison","Je ne me souviens pas")

df = data.frame(Num_ETAT_ANCIEN_TEL=matrice[1,],ETAT_ANCIEN_TEL=labels,Nb_personnes=matrice[2,] )
print(df)
```

#### **1 ) Matrice de "corrélation" donnant les liens entre chaque modalité (en valeur absolue)**

La matrice ci dessous étant symétrique, les valeurs en dessous de la
diagonale ont été remplacées par des 0, pour faciliter la lecture. La
diagonale de la matrice quant à elle correspond au nombre de fois où la
modalité est a été la seule à être choisie sans être liée à une ou
plusieurs autres modalités :

```{r echo=FALSE}
variable = data[which(data$RETAT_ANCIEN_TEL!=""),"RETAT_ANCIEN_TEL"]

mat = matrix(0,ncol=11,nrow=11)
for (i in 1:ncol(mat)){
  for (j in 1:length(variable)){
    liste_etats=str_extract_all(variable[j], ".{2}")[[1]]
    liste_etats=as.numeric(liste_etats)
    if (i %in% liste_etats){
      for (k in 1:length(liste_etats) ){
        etat=liste_etats[k]
        mat[etat,i]=mat[etat,i]+1
      }
    }
    if (length(liste_etats)==1 && i %in% liste_etats ){
      mat[11,i]=mat[11,i]+1
    }
  }
}

mat=t(mat)

# la matrice étant symétrique, on remplace les valeurs en dessous de la diagonale par des 0
mat[lower.tri(mat)] <- 0

mat1=mat[1:10,1:10]
diag(mat1)=mat[1:10,11]
diag_mat=diag(mat)

mat1

```

#### **2 ) Matrice de "corrélation" donnant les liens entre chaque modalité (en pourcentage)**

La matrice ci-dessous permet d'observer les mêmes informations que la
matrice précédente mais en terme de poucentage :

```{r echo=FALSE}
mat_pourcent1 = mat

for (i in 1:(ncol(mat)-1)){
  mat_pourcent1[,i]=round(mat_pourcent1[,i]*100/mat_pourcent1[i,i])
}

mat_pourcent1[,11]=round(mat_pourcent1[,11]*100/diag_mat)

mat_pourcent2=mat_pourcent1[1:10,1:10]
diag(mat_pourcent2) = mat_pourcent1[1:10,11]

mat_pourcent2
```

#### **3 ) Graphique permettant de visualiser ces matrices**

```{r echo=FALSE}
df <- as.data.frame(as.table(mat_pourcent2))
colnames(df) <- c("Etat_1", "Etat_2", "Value")

labels= c("Mon téléphone fonctionnait bien","Mon téléphone fonctionnait mais il lui manquait une ou plusieurs fonctionnalités","Mon téléphone était complètement inutilisable","La durée de vie de la batterie était faible","Le stockage de mon téléphone était insuffisant","Mon téléphone était lent","Mon téléphone était physiquement endommagé","Mon téléphone avait des dysfonctionnements","Autre raison","Je ne me souviens pas")


df$Etat_1 = factor(df$Etat_1, labels=c(1:10))
df$Etat_2 = factor(df$Etat_2, labels=c(1:10))

# Créer la heatmap
p <- ggplot(df, aes(x = Etat_2, y = Etat_1, fill = Value)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(title = "Etat(s) de l'ancien téléphone",
       x = "Etat",
       y = "Etat",
       fill = "Valeur") +
  theme_minimal() +
  theme(axis.title.x = element_text(face = "bold"),
        axis.title.y = element_text(face = "bold"),
        plot.title = element_text(hjust = 0.5, face = "bold"))

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

### **II ) Type de Résolution en fonction du degré de gêne**

```{r include=FALSE}
# Initialisation des vecteurs pour stocker les valeurs de recence, année, et mois
recence <- c()
annee <- c()
mois <- c()
gene <- c()
rep <- c()

# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105 (indice des colonnes reparation)
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 4 || val == 5)) {
      RECENCE <- df[j, i - 25]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(RECENCE)) {
        recence <- c(recence, RECENCE)
        annee <- c(annee, df[j, "DATEOBTENTIONSMART_1"])
        mois <- c(mois, df[j, "DATEOBTENTIONSMART_2"])
        gene <- c(gene,df[j, i - 50])
        rep = c(rep,val)
      }
    }
  }
}

# Suppression de la raison 7 dans la liste recence 

indices_rec_7= which(recence==7)
gene=gene[-c(indices_rec_7)]
rep = rep[-c(indices_rec_7)]

# Afficher les résultats pour vérifier
print(head(recence))
print(head(annee))
print(head(mois))
print(head(gene))
print(head(rep))
```

```{r include=FALSE}
gene_pbs_non_resolus=as.matrix(table(gene))
gene_pbs_non_resolus
```

```{r include=FALSE}
gene_tente_pas_reussi <- c()
gene_pbs_resolus <- c()
gene_resolu_seul <- c()

# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105 (indice des colonnes reparation)
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 1)) {
      g <- df[j, i - 50]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(g)) {
        gene_pbs_resolus <- c(gene_pbs_resolus,g)
      }
    }
    if (!is.na(val) && (val == 2)) {
      g <- df[j, i - 50]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(g)) {
        gene_tente_pas_reussi <- c(gene_tente_pas_reussi,g)
      }
    }
    if (!is.na(val) && (val == 3)) {
      g <- df[j, i - 50]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(g)) {
        gene_resolu_seul <- c(gene_resolu_seul,g)
      }
  }
  }
}

gene_pbs_resolus=as.matrix(table(gene_pbs_resolus))
gene_tente_pas_reussi=as.matrix(table(gene_tente_pas_reussi))
gene_resolu_seul = as.matrix(table(gene_resolu_seul))

print(gene_pbs_resolus)
print(gene_tente_pas_reussi)
print(gene_resolu_seul)
```

```{r include=FALSE}
# Types de résolution en abscisse et gêne en ordonné
indices_rep_4= which(rep==4)
gene_pbs_non_resolus_rep_4 <- gene[-c(indices_rep_4)] 
gene_pbs_non_resolus_rep_4 <- as.matrix(table(gene_pbs_non_resolus_rep_4))

indices_rep_5= which(rep==5)
gene_pbs_non_resolus_rep_5 <- gene[-c(indices_rep_5)] 
gene_pbs_non_resolus_rep_5 <- as.matrix(table(gene_pbs_non_resolus_rep_5))




mat=matrix(0,nrow=3,ncol=5)
mat[,1]=gene_pbs_resolus[,1]
mat[,2]=gene_tente_pas_reussi[,1]
mat[,3] = gene_resolu_seul[,1]
mat[,4]=gene_pbs_non_resolus_rep_4 
mat[,5] =gene_pbs_non_resolus_rep_5

print(mat)
print(sum(mat))

total=rowSums(mat)
print(total)

normalize <- function(x) {
  return(round(x*100/total))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat <- t(apply(mat, 2, normalize))
print(normalized_mat)
```

```{r include=FALSE}
resolution_label=c("Le problème est resolu","Le problème n'a pas pu être résolu","Le problème s’est résolu tout seul au bout d’un moment","Le problème sera peut-être résolu plus tard","Je ne pense pas tenter de résoudre le problème")

Catégorie = factor(label_GENE[1:3], levels = label_GENE[1:3])

df_T1 <- data.frame(Catégorie = Catégorie, valeurs = mat[,1], Légende = factor("Le problème est resolu",levels=resolution_label))
df_T2 <- data.frame(Catégorie = Catégorie, valeurs = mat[,2], Légende = factor("Le problème n'a pas pu être résolu",levels=resolution_label))
df_T3 <- data.frame(Catégorie = Catégorie, valeurs = mat[,3], Légende = factor("Le problème s’est résolu tout seul au bout d’un moment",levels=resolution_label))
df_T4 <- data.frame(Catégorie = Catégorie, valeurs = mat[,4], Légende = factor("Le problème sera peut-être résolu plus tard",levels=resolution_label))
df_T5 <- data.frame(Catégorie = Catégorie, valeurs = mat[,5], Légende = factor("Je ne pense pas tenter de résoudre le problème",levels=resolution_label))

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2,df_T3,df_T4,df_T5)

# Créer un diagramme en barres empilées
p5 <- ggplot(df_combined, aes(x = Catégorie, y = valeurs, fill = Légende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" si on veut des barres côtes à côtes
  labs(title = "Résolution en fonction du degrés de gêne",
       x = "Degrés de gêne",
       y = "Nombre de dysfonctionnements") +
  scale_fill_manual(values = c("Le problème est resolu"="#33a02c",
"Le problème n'a pas pu être résolu"="#FFD700","Le problème s’est résolu tout seul au bout d’un moment"="gray","Le problème sera peut-être résolu plus tard"="#fdb462","Je ne pense pas tenter de résoudre le problème"="#e31a1c")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.title.y = element_text(face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) 

p5_interactif <- ggplotly(p5)

# Afficher le graphique interactif
p5_interactif 
```

```{r include=FALSE}
resolution_label=c("Le problème est resolu","Le problème n'a pas pu être résolu","Le problème s’est résolu tout seul au bout d’un moment","Le problème sera peut-être résolu plus tard","Je ne pense pas tenter de résoudre le problème")

Catégorie = factor(label_GENE[1:3], levels = label_GENE[1:3])

df_T1 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[1,], Légende = factor("Le problème est resolu",levels=resolution_label))
df_T2 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[2,], Légende = factor("Le problème n'a pas pu être résolu",levels=resolution_label))
df_T3 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[3,], Légende = factor("Le problème s’est résolu tout seul au bout d’un moment",levels=resolution_label))
df_T4 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[4,], Légende = factor("Le problème sera peut-être résolu plus tard",levels=resolution_label))
df_T5 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[5,], Légende = factor("Je ne pense pas tenter de résoudre le problème",levels=resolution_label))

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2,df_T3,df_T4,df_T5)

# Créer un diagramme en barres empilées
p6 <- ggplot(df_combined, aes(x = Catégorie, y = valeurs, fill = Légende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" so on veut des barres côtes à côtes
  labs(title = "Résolution en fonction du degrés de gêne",
       x = "Degrés de gêne",
       y = "Pourcentage de dysfonctionnements") +
  scale_fill_manual(values = c("Le problème est resolu"="#33a02c",
"Le problème n'a pas pu être résolu"="#FFD700","Le problème s’est résolu tout seul au bout d’un moment"="gray","Le problème sera peut-être résolu plus tard"="#fdb462","Je ne pense pas tenter de résoudre le problème"="#e31a1c")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),  
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold"),legend.position="none") 

p6_interactif <- ggplotly(p6)

# Afficher le graphique interactif
p6_interactif 
```

```{r echo=FALSE}
# Utiliser subplot pour afficher les graphiques côte à côte
library(plotly)

subplot(
  p5_interactif, p6_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)  # Ajuster les largeurs pour plus d'espace
) %>%
  layout(
    title = list(
      text = "Résolution en fonction du degrés de gêne",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")  # Taille augmentée pour le titre principal
    ),
    annotations = list(
      list(
        x = 0.2, y = 1.05, text = "Sur 787 dysfonctionnements", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "black", family = "Arial", face = "bold")  # Correction pour la police en gras
      ),
      list(
        x = 0.8, y = 1.05, text = "Sur le même niveau", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "black", family = "Arial", face = "bold")  # Correction pour la police en gras
      )
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace pour les titres
    xaxis = list(domain = c(0, 0.45)),  # Ajuster la position du premier graphique
    xaxis2 = list(domain = c(0.55, 1))  # Ajuster la position du deuxième graphique
  )


```

### **III ) Pourquoi les gens n'ont pas voulu réparer**

Les graphes qui suic=vent permettent de visualiser pour chacune des
catégories (Stockage, Matériel, Mise à jour, Dysfonctionnement divers)
la répartition des raisons qui ont fait que les gens n'ont pas voulu
réparer leur téléphone.

```{r include=FALSE}
Count_VCM(data$RRAISON_UTIL_PB_FORM,13)
```

```{r include=FALSE}
mat_raison_cat = matrix(0,nrow=13,ncol=4)
mat_raison_gene = matrix(0,nrow=13,ncol=4)

liste_pbs_pas_resolu = c()

df = data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]

for ( i in 81:105){
  for (j in 1:nrow(df)){
    res=df[j,i]
    if (!is.na(res) && (res == 4 || res == 5)){
      gene=df[j,i-50]
      num_pb=i-80
      liste_pbs_pas_resolu = c(liste_pbs_pas_resolu,num_pb)
      result <- which(matrice_cat == num_pb, arr.ind = TRUE)
      cat <- result[1]
      liste = str_extract_all(df[j,"RRAISON_UTIL_PB_FORM"], ".{2}")[[1]]
      liste=as.numeric(liste)
      for (raison in liste){
        mat_raison_cat[raison,cat]=mat_raison_cat[raison,cat]+1
        mat_raison_gene[raison,gene]=mat_raison_gene[raison,gene]+1
      }
      
    }
    
  }
}



print(mat_raison_cat)
print(mat_raison_gene)

print(length(liste_pbs_pas_resolu)) # 331
print(sum(mat_raison_cat)) # 679
print(sum(mat_raison_gene)) # 679


normalize1 <- function(x) {
  return(round(x*100/colSums(mat_raison_cat),1))
}

normalize2 <- function(x) {
  return(round(x*100/colSums(mat_raison_gene),1))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat_raison_cat <- t(apply(mat_raison_cat,1, normalize1))
normalized_mat_raison_gene <- t(apply(mat_raison_gene,1, normalize2))

```

-   **Stockage :**

```{r echo=FALSE}
# STOCKAGE

df_T <- data.frame(Raisons=c(1:length(label_RAISON_UTIL_PB)),Valeurs = mat_raison_cat[,1], Légende = factor(label_RAISON_UTIL_PB,levels=label_RAISON_UTIL_PB))

# Créer un diagramme en barres empilées
p <- ggplot(df_T, aes(x = Raisons, y = Valeurs, fill = Légende)) +
  geom_bar(stat = "identity") + # mettre position = "dodge" si on veut des barres côtes à côtes
  labs(title = "Stockage ",
       x = "Raisons",
       y = "Nombre de dysfonctionnnements") +
  scale_fill_manual(values =c("#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#00FFFF", "#FF00FF", "#FFA500", "#800080", "#A52A2A", "#FFC0CB", "#808080", "#000000", "azure2","#00868B")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

-   **Matériel :**

```{r echo=FALSE}
# MATÉRIEL

df_T <- data.frame(Raisons=c(1:length(label_RAISON_UTIL_PB)),Valeurs = mat_raison_cat[,2], Légende = factor(label_RAISON_UTIL_PB,levels=label_RAISON_UTIL_PB))

# Créer un diagramme en barres empilées
p <- ggplot(df_T, aes(x = Raisons, y = Valeurs, fill = Légende)) +
  geom_bar(stat = "identity") + # mettre position = "dodge" si on veut des barres côtes à côtes
  labs(title = "Matériel ",
       x = "Raisons",
       y = "Nombre de dysfonctionnnements") +
  scale_fill_manual(values =c("#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#00FFFF", "#FF00FF", "#FFA500", "#800080", "#A52A2A", "#FFC0CB", "#808080", "#000000", "azure2","#00868B")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

-   **Mise à jour :**

```{r echo=FALSE}
# MAJ

df_T <- data.frame(Raisons=c(1:length(label_RAISON_UTIL_PB)),Valeurs = mat_raison_cat[,3], Légende = factor(label_RAISON_UTIL_PB,levels=label_RAISON_UTIL_PB))

# Créer un diagramme en barres empilées
p <- ggplot(df_T, aes(x = Raisons, y = Valeurs, fill = Légende)) +
  geom_bar(stat = "identity") + # mettre position = "dodge" si on veut des barres côtes à côtes
  labs(title = "Maj ",
       x = "Raisons",
       y = "Nombre de dysfonctionnnements") +
  scale_fill_manual(values =c("#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#00FFFF", "#FF00FF", "#FFA500", "#800080", "#A52A2A", "#FFC0CB", "#808080", "#000000", "azure2","#00868B")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

-   **Dysfonctionnement divers :**

```{r echo=FALSE}
# DYS DIVERS

df_T <- data.frame(Raisons=c(1:length(label_RAISON_UTIL_PB)),Valeurs = mat_raison_cat[,4], Légende = factor(label_RAISON_UTIL_PB,levels=label_RAISON_UTIL_PB))

# Créer un diagramme en barres empilées
p <- ggplot(df_T, aes(x = Raisons, y = Valeurs, fill = Légende)) +
  geom_bar(stat = "identity") + # mettre position = "dodge" si on veut des barres côtes à côtes
  labs(title = "Dys divers ",
       x = "Raisons",
       y = "Nombre de dysfonctionnnements") +
  scale_fill_manual(values =c("#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#00FFFF", "#FF00FF", "#FFA500", "#800080", "#A52A2A", "#FFC0CB", "#808080", "#000000", "azure2","#00868B")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

### **IV ) Intention de remplacement en fonction de l'année d'obtention du smartphone**

**Remarque :** La taille du point dépend du nombre de personnes
concernées par le cas concidéré, plus le point est gros, plus le nombre
de personnes dans le cas concidéré est important

```{r include=FALSE}
annees <- sort(unique(data$DATEOBTENTIONSMART_1))

# Créer un dataframe vide avec les bonnes dimensions
dataframe <- data.frame(REMPLACEMENT = 1:7)

# Obtenir tous les niveaux de INTENTION_REMPLACEMENT
all_levels <- sort(unique(data$INTENTION_REMPLACEMENT))

# Remplir le dataframe dans une boucle for
for (i in annees) {
  # Filtrer les données pour l'année en cours
  variable <- data[data$DATEOBTENTIONSMART_1 == i, "INTENTION_REMPLACEMENT"]
  
  # Créer une table de fréquences avec tous les niveaux et remplacer les niveaux manquants par zéro
  freq_table <- table(factor(variable, levels = all_levels))
  
  # Convertir en matrice pour un accès facile
  mat <- as.matrix(freq_table)
  
  # Ajouter les valeurs au dataframe, en s'assurant qu'elles soient correctement alignées avec les niveaux
  dataframe[, as.character(i)] <- ifelse(is.na(mat), 0, mat[, 1])
}

dataframe$REMPLACEMENT = factor(dataframe$REMPLACEMENT,labels=c("Oui, dans moins d’un mois","Oui, dans 1 à 6 mois","Oui, dans 6 à 12 mois","Oui, dans 1 an à 2 ans","Oui, dans 2 ans ou plus","Non, je n’ai pas envisagé de le remplacer","Je ne sais pas"))

# Afficher le dataframe résultant
print(dataframe)


```

```{r echo=FALSE}
# Initialiser les années
annees <- sort(unique(data$DATEOBTENTIONSMART_1))

# Obtenir tous les niveaux de INTENTION_REMPLACEMENT
all_levels <- sort(unique(data$INTENTION_REMPLACEMENT))

# Créer une liste pour stocker les résultats
result_list <- list()

# Remplir la liste dans une boucle for
for (i in annees) {
  # Filtrer les données pour l'année en cours
  variable <- data[data$DATEOBTENTIONSMART_1 == i, "INTENTION_REMPLACEMENT"]
  
  # Créer une table de fréquences avec tous les niveaux et remplacer les niveaux manquants par zéro
  freq_table <- table(factor(variable, levels = all_levels))
  
  # Convertir en DataFrame
  df_temp <- data.frame(
    Obtention = i,
    Remplacement = names(freq_table),
    Nb_personnes_concernees = as.numeric(freq_table)
  )
  
  # Ajouter le DataFrame temporaire à la liste
  result_list[[as.character(i)]] <- df_temp
}

# Combiner tous les DataFrames en un seul
df2 <- do.call(rbind, result_list)
# Filtrer les données pour exclure les points où la valeur est zéro
df2 <- df2[df2$Nb_personnes_concernees > 0, ]
df2$Remplacement = factor(df2$Remplacement,labels=c("Dans moins d’un mois","Dans 1 à 6 mois","Dans 6 à 12 mois","Dans 1 an à 2 ans","Dans 2 ans ou plus","Je n’ai pas envisagé de le remplacer","Je ne sais pas"))

# sum(df2$Nb_personnes_concernees) # 968

# Créer le graphique
p <- ggplot(df2, aes(x = Obtention, y = Remplacement, size = Nb_personnes_concernees)) +
  geom_point(alpha = 0.7, col = "turquoise4") +
  theme_minimal() +
  labs(title = "Intention de remplacement en fonction de l'année d'obtention",
       x = "Année d'obtention",
       y = "Intention de remplacement",
       size = "Nb de personne(s) concernée(s)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", colour = "turquoise4"),
        axis.title.x = element_text(face = "bold", colour = "turquoise4"),
        axis.title.y = element_text(face = "bold", colour = "turquoise4"))
# Rendre le graphique interactif
p_interactif <- ggplotly(p, tooltip = c("x", "y", "size"))

# Afficher le graphique interactif
p_interactif


```

```{r}

```

### **V ) Intention de remplacement en fonction de la durée d'utilisation précédente du téléphone d'occasion**

**Remarque :** La taille du point dépend du nombre de personnes
concernées par le cas concidéré, plus le point est gros, plus le nombre
de personnes dans le cas concidéré est important

```{r include=FALSE}
# Initialiser les années
duree <- sort(unique(data$UTILISATIONSMARTOCCAS))

# Obtenir tous les niveaux de INTENTION_REMPLACEMENT
all_levels <- sort(unique(data$UTILISATIONSMARTOCCAS))

# Créer une liste pour stocker les résultats
result_list <- list()

# Remplir la liste dans une boucle for
for (i in duree) {
  # Filtrer les données pour l'année en cours
  variable <- data[data$UTILISATIONSMARTOCCAS == i, "INTENTION_REMPLACEMENT"]
  
  # Créer une table de fréquences avec tous les niveaux et remplacer les niveaux manquants par zéro
  freq_table <- table(factor(variable, levels = all_levels))
  
  # Convertir en DataFrame
  df_temp <- data.frame(
    Duree_usage_ancien_tel = i,
    Remplacement = names(freq_table),
    Nb_personnes_concernees = as.numeric(freq_table)
  )
  
  # Ajouter le DataFrame temporaire à la liste
  result_list[[as.character(i)]] <- df_temp
}

# Combiner tous les DataFrames en un seul
df2 <- do.call(rbind, result_list)
# Filtrer les données pour exclure les points où la valeur est zéro
df2 <- df2[df2$Nb_personnes_concernees > 0, ]
df2$Remplacement = factor(df2$Remplacement,labels=c("Dans moins d’un mois","Dans 1 à 6 mois","Dans 6 à 12 mois","Dans 1 an à 2 ans","Dans 2 ans ou plus","Je n’ai pas envisagé de le remplacer","Je ne sais pas"))

df2$Duree_usage_ancien_tel = factor(df2$Duree_usage_ancien_tel,labels=c("Moins de 6 mois","Entre 6 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Entre 3 et 5 ans","Plus de 5 ans","Je ne sais pas"))

# sum(df2$Nb_personnes_concernees) # 88
```

```{r echo=FALSE}
p <- ggplot(df2, aes(x =Remplacement, y = Duree_usage_ancien_tel, size = Nb_personnes_concernees)) +
  geom_point(alpha = 0.7, col = "turquoise4") +
  theme_minimal() +
  labs(title = "Intention de remplacement en fonction de la durée d’utilisation précédente du téléphone d’occasion",
       x = "Intention de remplacement",
       y = "Durée usage ancien téléphone",
       size = "Nb de personne(s) concernée(s)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", colour = "turquoise4"),
        axis.title.x = element_text(face = "bold", colour = "turquoise4"),
        axis.title.y = element_text(face = "bold", colour = "turquoise4"),  
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
# Rendre le graphique interactif
p_interactif <- ggplotly(p, tooltip = c("x", "y", "size"))

# Afficher le graphique interactif
p_interactif
```

### **VI ) Degrés de gêne et temps de cohabitation par catégorie de dysfonctionnements**

```{r include=FALSE}
### Création d'un dataframe avec 4 colonnes : le numéro du dys, la catégorie du dys, le degre de gêne du dys et le temps de cohabitation du dys :

# dys qui ont tenté d'être résoud ou qui ont été résolus

pbs = c()
cate_dys = c()
deg_gene = c()
cohab = c()

df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27" & data$RIDENTIFICATION_PROBLEMES != "26"),]
variable = df$RIDENTIFICATION_PROBLEMES

for (i in 1:length(variable)){
  liste_pbs =str_extract_all(variable[i], ".{2}")[[1]]
  liste_pbs = as.numeric(liste_pbs)
  for (j in 1:length(liste_pbs)){
    pb = liste_pbs[j]
    num=as.character(pb)
    g=paste0("GENE_PROBLEMES_A",num)
    gene=df[i,g]
    c= paste0("COHABITATION_DYSFONCTION_A",num)
    coha = df[i,c]
    if(!is.null(gene) && !is.na(gene) && !is.null(coha) && !is.na(coha)){
      
      result <- which(matrice_cat == pb, arr.ind = TRUE)
      cat <- result[1]
      pbs = c(pbs,pb)
      cate_dys = c(cate_dys,cat)
      deg_gene = c(deg_gene,gene)
      cohab = c(cohab,coha)
        }
  }
}

#print(head(pbs))
#print(head(cate_dys))
#print(head(deg_gene))
#print((head(cohab)))

print(length(pbs))
print(length(cate_dys))
print(length(deg_gene))
print(length(cohab))



don = data.frame()
don <- data.frame( "Categorie_dys"=cate_dys, "Gêne"=deg_gene,"Cohab"=cohab)
don[which(don$Cohab==1),"Cohab"]=2 # On lie les "moins d'un mois" et les "dès que j'ai décelé le dys" ensemble
print(head(don))
print(nrow(don))
```

```{r include=FALSE}
COHAB_non_resolus <- c( 3, 2, 3, 4, 4, 4, 3, 3, 3, 4, 4, 4, 3, 4, 3, 4, 1, 3, 3, 2, 2, 4, 4, 3, 4, 4, 2, 3, 4, 3, 3, 4, 3, 4, 3, 2, 3, 1, 3, 4, 2, 2, 3, 3, 4, 4, 3, 2, 4,2, 3, 3, 3, 2, 3, 3, 3, 4, 3, 4, 2, 3, 3, 2, 4, 4, 3, 4, 2, 4, 3, 4, 3, 3, 3, 4, 2, 3, 4, 3, 3, 4, 3, 4, 4, 4, 4, 4, 2, 3, 2, 2, 4, 3, 3, 2, 3, 3,4, 4, 3, 2, 3, 4, 4, 3, 3, 4, 3, 3, 3, 4, 4, 2, 4, 4, 2, 4, 3, 4, 4, 3, 3, 4, 4, 4, 3, 4, 2, 3, 1, 2, 4, 3, 3, 4, 4, 3, 4, 3, 3, 4, 4, 4, 3, 4, 3,3, 4, 3, 4, 2, 2, 3, 3, 1, 2, 3, 2, 3, 3, 4, 4, 3, 4, 3, 3, 4, 4, 4, 3, 3, 2, 4, 3, 1, 2, 3, 4, 2, 4, 3, 4, 4, 4, 3, 3, 4, 3, 3, 2, 3, 2, 4, 4, 4,3, 4, 3, 3, 1, 3, 2, 4, 4, 3, 2, 4, 3, 4, 3, 4, 3, 4, 4, 4, 3, 4, 3, 3, 2, 4, 3, 3, 4, 2, 2, 4, 3, 3, 3, 4, 1, 4, 4, 4, 3, 3, 4, 3, 4, 2, 3, 4, 3,4,3 ,4 ,4 ,4 ,4 ,4, 3, 4, 3, 4, 2, 3, 4, 3, 3, 3, 3, 4, 4, 2, 4, 4, 4, 3, 2, 3, 4, 4, 4, 3, 3, 2, 3, 4, 3, 4, 4, 4, 3, 2, 4, 4, 1, 3, 2, 4, 4, 3,2, 4, 4, 3, 4, 4, 4, 4, 3, 2, 4, 3, 4, 4, 3, 4, 3, 1, 3, 3, 2, 3)

nb_non_resolus <- length(COHAB_non_resolus) # 316
```

```{r include=FALSE}
# dys qui  n'ont pas été résolus

# Initialisation des vecteurs pour stocker les valeurs de recence, année, et mois
recence <- c()
annee <- c()
mois <- c()
gene <- c()
pbs = c()
cate_dys = c()


# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105 (indice des colonnes reparation)
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 4 || val == 5)) {
      RECENCE <- df[j, i - 25]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(RECENCE)) {
        recence <- c(recence, RECENCE)
        annee <- c(annee, df[j, "DATEOBTENTIONSMART_1"])
        mois <- c(mois, df[j, "DATEOBTENTIONSMART_2"])
        gene <- c(gene,df[j, i - 50])
        result <- which(matrice_cat == (i-80), arr.ind = TRUE)
        cat <- result[1]
        pbs = c(pbs,i-80)
        cate_dys = c(cate_dys,cat)
      }
    }
  }
}

# Suppression de la raison 7 dans la liste recence 

indices_rec_7= which(recence==7)
gene=gene[-c(indices_rec_7)]
pbs=pbs[-c(indices_rec_7)]
cate_dys=cate_dys[-c(indices_rec_7)]

don2 <- data.frame( "Categorie_dys"=cate_dys, "Gêne"=gene,"Cohab"=COHAB_non_resolus+1)

# Afficher les résultats pour vérifier
print(head(pbs))
print(head(cate_dys))
print(head(gene))

# Jointure des dataframe entre eux 
don <- rbind(don,don2)

# Création d'un autre dataframe pour une future jointure 
don1 <- rbind(don,don2)

head(don)
nrow(don)
nrow(don2)
```

```{r include=FALSE}
# calcul du nombre de personnes pour les différents cas possibles

liste = c()
for (k in 1:nrow(don)){
  i = don[k,"Gêne"]
  j = don[k,"Categorie_dys"]
  l = don[k,"Cohab"]
  df2 <- don[which(don$Categorie_dys==j & don$Gêne==i & don$Cohab==l),]
  nb = nrow(df2)
  liste = c(liste,nb)
  
}
don$nb <- liste
don <- unique(don)
don <- don %>% 
  arrange( Cohab,Categorie_dys,Gêne)

lab<- c("Dys Stockage trés gênant","Dys Stockage plutôt gênant","Dys Stockage plutôt pas gênant","Dys Matériel trés gênant","Dys Matériel plutôt gênant","Dys Matériel plutôt pas gênant","Dys Maj trés gênant","Dys Maj plutôt gênant","Dys Maj plutôt pas gênant", "Dys divers trés gênant","Dys divers plutôt gênant","Dys divers plutôt pas gênant")

df <- data.frame(
  Colonne1 = lab[1:3],
  Colonne2 = lab[4:6],
  Colonne3 = lab[7:9],
  Colonne4 = lab[10:12]
)

label=c()
for(i in 1:nrow(don)){
  gene = don[i,"Gêne"]
  cat = don[i,"Categorie_dys"]
  label=c(label,df[gene,cat])
}

don$label= label

print(don)
nrow(don)
```

```{r include=FALSE}
# moins d'un mois
moins_1_mois <- don[don$Cohab==2,]
matrice = matrix(0,nrow=3,ncol=4)

for ( i in 1:ncol(matrice)){
  for (j in 1:nrow(matrice)){
    matrice[j,i]=moins_1_mois[which(moins_1_mois$Gêne==j & moins_1_mois$Categorie_dys==i),"nb"]
  }
}
matrice

normalize3 <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat3 <- t(apply(matrice,1, normalize3))
print(normalized_mat3)

Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[1,], GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*normalized_mat3[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$abs_valeurs <- abs(df_combined$valeurs)

df_combined$GÊNE <- factor(df_combined$GÊNE, levels = c("Très gênant", "Plutôt gênant", "Plutôt pas gênant"))

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 0.5) +
  labs(title = "Moins d'un mois ",
       x = "Catégorie dysfonctionnement ",
       y = "Frequency ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +scale_y_continuous(labels = function(x) abs(x), breaks = seq(-50, 100, by = 25)) + # 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold")) 

p_interactif <- ggplotly(p)

df_T1 <- data.frame(Categorie = Categorie, valeurs = (matrice[1,]), GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = matrice[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$GÊNE = factor(df_combined$GÊNE,levels=label_GENE)

# Créer un diagramme en barres empilées
p1 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 0.5) +
  labs(title = "Mois d'un mois",
       x = " ",
       y = "Count ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold"),legend.position="none") 

p1_interactif <- ggplotly(p1)

```

```{r echo=FALSE}
subplot(
  p_interactif, p1_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Cohabitation : Mois d'un mois",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")
    
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)),  # Déplacer le deuxième graphique vers la droite
    yaxis2 = list(showticklabels = FALSE))
```

```{r include=FALSE}
# 1 à 6 mois
un_et_6_mois <- don[don$Cohab==3,] 
un_et_6_mois$nb[is.na(un_et_6_mois$nb)] <- 0

# Initialiser la matrice avec des zéros
matrice <- matrix(0, nrow = max(un_et_6_mois$Gêne), ncol = max(un_et_6_mois$Categorie_dys))

# Remplir la matrice avec des valeurs du dataframe 'un_et_6_mois'
for (i in 1:ncol(matrice)) {
  for (j in 1:nrow(matrice)) {
    val <- un_et_6_mois[which(un_et_6_mois$Gêne == j & un_et_6_mois$Categorie_dys == i), "nb"]
    if (length(val) > 0 && !is.na(val)) {
      matrice[j, i] <- val
    }
  }
}

normalize3 <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat3 <- t(apply(matrice,1, normalize3))
print(normalized_mat3)

Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[1,], GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*normalized_mat3[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$abs_valeurs <- abs(df_combined$valeurs)

df_combined$GÊNE <- factor(df_combined$GÊNE, levels = c("Très gênant", "Plutôt gênant", "Plutôt pas gênant"))

# Créer un diagramme en barres empilées
p2 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 0.5) +
  labs(title = "1 à 6 mois ",
       x = "Catégorie dysfonctionnement ",
       y = "Frequency ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +scale_y_continuous(labels = function(x) abs(x), breaks = seq(-50, 100, by = 25)) + # 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold")) 

p2_interactif <- ggplotly(p2)

df_T1 <- data.frame(Categorie = Categorie, valeurs = (matrice[1,]), GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = matrice[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$GÊNE = factor(df_combined$GÊNE,levels=label_GENE)

# Créer un diagramme en barres empilées
p3 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 0.5) +
  labs(title = "1 à 6 mois",
       x = " ",
       y = "Count ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold"),legend.position="none") 

p3_interactif <- ggplotly(p3)
```

```{r echo=FALSE}
subplot(
  p2_interactif, p3_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Cohabitation : Entre 1 mois et 6 mois",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")
    
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)),  # Déplacer le deuxième graphique vers la droite
    yaxis2 = list(showticklabels = FALSE))
```

```{r include=FALSE}
############### 6 mois à 2 ans

six_mois_2ans <- don[don$Cohab==4,] 
six_mois_2ans$nb[is.na(six_mois_2ans$nb)] <- 0

# Initialiser la matrice avec des zéros
matrice <- matrix(0, nrow = max(six_mois_2ans$Gêne), ncol = max(six_mois_2ans$Categorie_dys))

for (i in 1:ncol(matrice)) {
  for (j in 1:nrow(matrice)) {
    val <- six_mois_2ans[which(six_mois_2ans$Gêne == j & six_mois_2ans$Categorie_dys == i), "nb"]
    if (length(val) > 0 && !is.na(val)) {
      matrice[j, i] <- val
    }
  }
}

normalize3 <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat3 <- t(apply(matrice,1, normalize3))
print(normalized_mat3)

Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[1,], GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*normalized_mat3[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$abs_valeurs <- abs(df_combined$valeurs)

df_combined$GÊNE <- factor(df_combined$GÊNE, levels = c("Très gênant", "Plutôt gênant", "Plutôt pas gênant"))

# Créer un diagramme en barres empilées
p4 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 0.5) +
  labs(title = "6 mois à 2 ans ",
       x = " Catégorie dysfonctionnement",
       y = "Frequency ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +scale_y_continuous(labels = function(x) abs(x), breaks = seq(-50, 100, by = 25)) + # 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold")) 

p4_interactif <- ggplotly(p4)

df_T1 <- data.frame(Categorie = Categorie, valeurs = (matrice[1,]), GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = matrice[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$GÊNE = factor(df_combined$GÊNE,levels=label_GENE)

# Créer un diagramme en barres empilées
p5 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 0.5) +
  labs(title = "6 mois et 2 ans",
       x = " ",
       y = "Count ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold"),legend.position="none") 

p5_interactif <- ggplotly(p5)
```

```{r echo=FALSE}
subplot(
  p4_interactif, p5_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Cohabitation : Entre 6 mois et 2 ans",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")
    
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)),  # Déplacer le deuxième graphique vers la droite
    yaxis2 = list(showticklabels = FALSE))
```

```{r include=FALSE}
############### Plus de 2 ans

plus_de_2ans <- don[don$Cohab==5,] 
plus_de_2ans$nb[is.na(plus_de_2ans$nb)] <- 0

# Initialiser la matrice avec des zéros
matrice <- matrix(0, nrow = max(plus_de_2ans$Gêne), ncol = max(plus_de_2ans$Categorie_dys))

for (i in 1:ncol(matrice)) {
  for (j in 1:nrow(matrice)) {
    val <- plus_de_2ans[which(plus_de_2ans$Gêne == j & plus_de_2ans$Categorie_dys == i), "nb"]
    if (length(val) > 0 && !is.na(val)) {
      matrice[j, i] <- val
    }
  }
}

normalize3 <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat3 <- t(apply(matrice,1, normalize3))
print(normalized_mat3)

Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[1,], GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*normalized_mat3[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$abs_valeurs <- abs(df_combined$valeurs)

df_combined$GÊNE <- factor(df_combined$GÊNE, levels = c("Très gênant", "Plutôt gênant", "Plutôt pas gênant"))

# Créer un diagramme en barres empilées
p6 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 0.5) +
  labs(title = "Plus de 2 ans ",
       x = "Catégorie dysfonctionnement ",
       y = "Frequency ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +scale_y_continuous(labels = function(x) abs(x), breaks = seq(-50, 100, by = 25)) + # 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold")) 

p6_interactif <- ggplotly(p6)

df_T1 <- data.frame(Categorie = Categorie, valeurs = (matrice[1,]), GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = matrice[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$GÊNE = factor(df_combined$GÊNE,levels=label_GENE)

# Créer un diagramme en barres empilées
p7 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 0.5) +
  labs(title = "Plus de 2 ans",
       x = " ",
       y = "Count ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold"),legend.position="none") 

p7_interactif <- ggplotly(p7)
```

```{r echo=FALSE}
subplot(
  p6_interactif, p7_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Cohabitation : Plus de 2 ans",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")
    
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)),  # Déplacer le deuxième graphique vers la droite
    yaxis2 = list(showticklabels = FALSE))
```

```{r include=FALSE}
############### Je ne sais pas

jsp <- don[don$Cohab==6,] 
jsp$nb[is.na(jsp$nb)] <- 0

# Initialiser la matrice avec des zéros
matrice <- matrix(0, nrow = max(jsp$Gêne), ncol = max(jsp$Categorie_dys))

for (i in 1:ncol(matrice)) {
  for (j in 1:nrow(matrice)) {
    val <- jsp[which(jsp$Gêne == j & jsp$Categorie_dys == i), "nb"]
    if (length(val) > 0 && !is.na(val)) {
      matrice[j, i] <- val
    }
  }
}

normalize3 <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat3 <- t(apply(matrice,1, normalize3))
print(normalized_mat3)

Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[1,], GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat3[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = (-1)*normalized_mat3[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$abs_valeurs <- abs(df_combined$valeurs)

df_combined$GÊNE <- factor(df_combined$GÊNE, levels = c("Très gênant", "Plutôt gênant", "Plutôt pas gênant"))

# Créer un diagramme en barres empilées
p8 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 0.5) +
  labs(title = "Je ne sais pas ",
       x = " Catégorie dysfonctionnement ",
       y = "Frequency ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +scale_y_continuous(labels = function(x) abs(x), breaks = seq(-50, 100, by = 25)) + # 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold")) 

p8_interactif <- ggplotly(p8)

df_T1 <- data.frame(Categorie = Categorie, valeurs = (matrice[1,]), GÊNE = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = matrice[2,], GÊNE = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = matrice[3,], GÊNE = "Plutôt pas gênant")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3)
df_combined$GÊNE = factor(df_combined$GÊNE,levels=label_GENE)

# Créer un diagramme en barres empilées
p9 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = GÊNE)) +
  geom_bar(stat = "identity", position = "stack",width = 0.5) +
  labs(title = "Je ne sais pas",
       x = " ",
       y = "Count ") +
  theme_minimal() +
  scale_fill_manual(values =  c("Très gênant"="red3","Plutôt gênant"="darkorange2","Plutôt pas gênant"="palegreen3")) +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),
        axis.title.y = element_text(face = "bold"),legend.position="none") 

p9_interactif <- ggplotly(p9)
```

```{r echo=FALSE}
subplot(
  p8_interactif, p9_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Cohabitation : Je ne sais pas",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")
    
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)),  # Déplacer le deuxième graphique vers la droite
    yaxis2 = list(showticklabels = FALSE))
```

### **VII ) Catégorie de dysfonctionnements**

#### **1 ) Catégorie 1 :**

-   Les catégories de la catégorisation 1 sont les suivantes :

**Problèmes matériels :** Problème de sensibilité du tactile, Problème
avec la lampe torche ou le flash, Problème de son, Problème de prise
jack, Problème de chargement,Problème de batterie Problème de capteurs,
Problème de téléphonie, Problème avec les boutons, Problème de vibreur

**Problèmes matériels + logiciels :** Problème avec l'écran, Problème
avec l'appareil photo, Problème avec le GPS, Problème avec le micro,
Problème de Wi-Fi, Problème d'accès à Internet, Problème lié à une
fonctionnalité manquante

**Problèmes logiciels :** Système d'exploitation non mis à jour,
Applications ne pouvant pas être téléchargées ou mises à jour,
Fonctionnalité qui ne marche plus, Dysfonctionnement logiciel, Problèmes
avec des applications, Problème de lenteur, Problème de Bluetooth ou de
transferts de fichiers sans fil, Stockage saturé

-   La représentation graphique qui suit permet de visualiser la
    répartition des dysfonctionnements concernés par chacune des
    catégories :

```{r include=FALSE}
label_dys <- c("Problèmes matériels","Problèmes matériels + logiciels","Problèmes logiciels")

materiel <- c(2,4,7,8,9,10,12,14,16,17)
materiel_logiciel <-c(1,3,5,6,11,15,21)
logiciel <- c(13,18,19,20,22,23,24,25)

# Trouver la liste qui contient le plus d'éléments pour après définir le nombre de colonnes de notre matrice
max_length <- max(length(materiel), length(materiel_logiciel), length(logiciel))

# Initialiser la matrice avec des zéros
matrice_cat <- matrix(0, nrow = 3, ncol = max_length)

# Remplir les lignes de la matrice avec les listes
matrice_cat[1, 1:length(materiel)] <- materiel
matrice_cat[2, 1:length(materiel_logiciel)] <- materiel_logiciel
matrice_cat[3, 1:length(logiciel)] <- logiciel

# Afficher la matrice
print(matrice_cat)
```

```{r include=FALSE}
variable=data$RIDENTIFICATION_PROBLEMES
nb_de_modalites = 25
valeurs = Count_VCM(variable,nb_de_modalites)

num_pb = c()
nb_pb = c()
cat_pb = c()

valeurs = Count_VCM(variable,nb_de_modalites)

for (i in 1:ncol(valeurs)){
  num_pb=c(num_pb,valeurs[1,i])
  nb_pb = c(nb_pb,valeurs[2,i])
  
  result <- which(matrice_cat == i, arr.ind = TRUE)
  cat <- result[1]
  
  cat_pb=c(cat_pb,cat)
}

dataframe = data.frame(Dys = num_pb, nb = nb_pb, Categorie = cat_pb)

dataframe <- dataframe %>% 
  arrange( Categorie,desc(nb))

dataframe$Dys = factor(dataframe$Dys, levels=1:length(label_RIDENTIFICATION_PROBLEME),labels=label_RIDENTIFICATION_PROBLEME)

dataframe$Categorie= factor(dataframe$Categorie, levels = 1:length(label_dys),labels=label_dys)

dataframe

nrow(dataframe[which(dataframe$Categorie=="Problèmes matériels"),]) # 10
nrow(dataframe[which(dataframe$Categorie=="Problèmes matériels + logiciels"),]) # 7
nrow(dataframe[which(dataframe$Categorie=="Problèmes logiciels"),]) # 8

```

```{r echo=FALSE}

label <- dataframe$Dys

# Teintes de Rouge
teintes <- c("#8B0000","#B22222", "#CD5C5C", "#DC143C", "#FF0000","#FF6347","#FF4500","#FF7F7F","#FF8C69","#FFA07A","#8B8000","#BDB76B","#F0E68C","#EEE8AA","#FFFF00","#FFFFE0", "#FFFFF0","orange","#FF4500","#FF8C00","#FFA500","#FFB347","#FFCC99","#FFDAB9","#FFE4B5","#FFFAF0")


dataframe$Dys = factor(dataframe$Dys,levels=label)

p <- ggplot(dataframe, aes(x = Categorie, y = nb, fill =Dys)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("#8B0000","#B22222", "#CD5C5C", "#DC143C", "#FF0000","#FF6347","#FF4500","#FF7F7F","#FF8C69","#FFA07A","#8B8000","#BDB76B","#F0E68C","#EEE8AA","#FFFF00","#FFFFE0", "#FFFFF0","#FF4500","#FF8C00","#FFA500","#FFB347","#FFCC99","#FFDAB9","#FFE4B5","#FFFAF0")) +
  labs(title = "Répartition des dysfonctionnements",
       x = "Catégorie",
       y = "Nombre de dysfonctionnements",
       fill = "Problème") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text(face = "bold"), 
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

# Affichage du graphique
p_interactif <- ggplotly(p)

# Affichage du graphique interactif
p_interactif
```

#### **2 ) Catégorie 2 : Gênes ressenties en fonction de la catégorie du dysfonctionnement :**

-   Les catégories de la catégorisation 2 sont les suivantes :

**Stockage :** Stockage saturé

**Mise à jour :** Système d'exploitation (par ex : Android, iOS...) non
mis à jour, Applications ne pouvant pas être téléchargées ou mises à
jour

**Matériel :** Problème avec l'écran, Problème de sensibilité du
tactile, Problème avec les boutons, Problème de vibreur, Problème de
capteurs, Problème de batterie, Problème de chargement, Problème de
prise jack, Problème de son, Problème avec le micro, Problème avec la
lampe torche ou le flash

**Dysfonctionnement divers :** Problème lié à une fonctionnalité
manquante, Fonctionnalité qui ne marche plus, Dysfonctionnement
logiciel, Problèmes avec des applications, Problème d'accès à Internet,
Problème de téléphonie, Problème de Bluetooth ou de transferts de
fichiers sans fil, Problème de Wi-Fi, Problème avec le GPS, Problème de
lenteur, Problème avec l'appareil photo

-   Le graphe qui suit permet de visualiser les types de gênes
    ressenties pour chacune de ces catégories :

```{r include=FALSE}
# Catégorisation des dysfonctionnements

label_dys <- c("Stockage","Matériel","Mise à jour","Dys divers")

materiel <- c(1,2,4,6,7,8,9,10,12,16,17)
dys_divers <- c(3,5,11,13,14,15,21,22,23,24,25)
stockage <- c(18)
maj <- c(19,20)

# Trouver la liste qui contient le plus d'éléments pour après définir le nombre de colonnes de notre matrice
max_length <- max(length(materiel), length(dys_divers), length(stockage), length(maj))

# Initialiser la matrice avec des zéros
matrice_cat <- matrix(0, nrow = 4, ncol = max_length)

# Remplir les lignes de la matrice avec les listes
matrice_cat[1, 1:length(stockage)] <- stockage
matrice_cat[2, 1:length(materiel)] <- materiel
matrice_cat[3, 1:length(maj)] <- maj
matrice_cat[4, 1:length(dys_divers)] <- dys_divers

# Afficher la matrice
print(matrice_cat)
```

```{r include=FALSE}
pbs= Count_VCM(data$RIDENTIFICATION_PROBLEMES,26)
nb_total_pbs <- sum(pbs[2,])

mat=matrix(0,nrow=2,ncol=length(label_dys))
mat[1,]=c(1:length(label_dys))

df = data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
variable = df$RIDENTIFICATION_PROBLEMES

for (i in 1:length(variable)){
  liste_pbs=str_extract_all(variable[i],".{2}")[[1]]
  liste_pbs=as.numeric(liste_pbs)
  for (j in liste_pbs){
    if (j %in% stockage){
      mat[2,1]=mat[2,1]+1
    }
    if (j %in% materiel){
      mat[2,2]=mat[2,2]+1
    }
    if (j %in% maj){
      mat[2,3]=mat[2,3]+1
    }
    if (j %in% dys_divers){
      mat[2,4]=mat[2,4]+1
    }
  }
}

don <- data.frame("Dysfonctionnements"=label_dys,"Nb_dys"=mat[2,],"Pourcentage_dys"=round(mat[2,]*100/nb_total_pbs))
print(don)
```

```{r include=FALSE}
CATEGORIE <- c(1:4)

mat <- matrix(0,nrow=5,ncol=length(CATEGORIE))
mat[1,] <- CATEGORIE

df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
variable=df$RIDENTIFICATION_PROBLEMES

for (i in 1:ncol(mat)){
  liste_val=matrice_cat[i,]
  for (j in 1:length(variable)){
  liste_pbs=str_extract_all(variable[j],".{2}")[[1]]
  liste_pbs=as.numeric(liste_pbs)
  for (k in liste_pbs){
    if (k %in% liste_val){
      num=as.character(k)
      nom_colonne=paste0("GENE_PROBLEMES_A",num)
      valeur=df[j,nom_colonne]
      if(!is.null(valeur) && !is.na(valeur)){
        mat[valeur+1,i]=mat[valeur+1,i]+1
        }
    }
  }
  }
  
}

df <- data.frame("Dysfonctionnements"=label_dys, "Nb_dys"=don$Nb_dys,"Trés gênant"=round(mat[2,]*100/don$Nb_dys),"Plutôt gênant"=round(mat[3,]*100/don$Nb_dys),"Plutôt pas gênant"=round(mat[4,]*100/don$Nb_dys),"Pas gênant du tout"=round(mat[5,]*100/don$Nb_dys))
print(df)
```

```{r include=FALSE}
matrice = mat[2:5,]

normalize <- function(x) {
  return(round(x*100/colSums(matrice)))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat <- t(apply(matrice,1, normalize))
print(normalized_mat)

```

```{r include=FALSE}
Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs =normalized_mat[1,], Gêne = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[2,], Gêne = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[3,], Gêne = "Plutôt pas gênant")
df_T4 <- data.frame(Categorie = Categorie, valeurs = normalized_mat[4,], Gêne = "Pas gênant du tout")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3, df_T4)
df_combined$Gêne=factor(df_combined$Gêne,levels=label_GENE)

# Créer un diagramme en barres empilées
p <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Gêne)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Type de gênes ressenties par catégorie",
       x = "Dysfonctionnements",
       y = "Pourcentage de dysfonctionnements ") +
  scale_fill_manual(values = c("Très gênant" = "#1f77b4", 
                               "Plutôt gênant" = "#6baed6", 
                               "Plutôt pas gênant" = "#9ecae1", 
                               "Pas gênant du tout" = "#c6dbef")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="#1f77b4"),
        axis.title.x = element_text( face = "bold",colour="#1f77b4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="#1f77b4")) 

p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 
```

```{r include=FALSE}
Categorie <- factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Categorie = Categorie, valeurs = mat[2,], Gêne = "Très gênant")
df_T2 <- data.frame(Categorie = Categorie, valeurs = mat[3,], Gêne = "Plutôt gênant")
df_T3 <- data.frame(Categorie = Categorie, valeurs = mat[4,], Gêne = "Plutôt pas gênant")
df_T4 <- data.frame(Categorie = Categorie, valeurs = mat[5,], Gêne = "Pas gênant du tout")


# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2, df_T3, df_T4)
df_combined$Gêne=factor(df_combined$Gêne,levels=label_GENE)

# Créer un diagramme en barres empilées
p1 <- ggplot(df_combined, aes(x = Categorie, y = valeurs, fill = Gêne)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Type de gênes ressenties par catégorie",
       x = "Dysfonctionnements",
       y = "Nombre de dysfonctionnements ") +
  scale_fill_manual(values = c("Très gênant" = "#1f77b4", 
                               "Plutôt gênant" = "#6baed6", 
                               "Plutôt pas gênant" = "#9ecae1", 
                               "Pas gênant du tout" = "#c6dbef")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="#1f77b4"),
        axis.title.x = element_text( face = "bold",colour="#1f77b4"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="#1f77b4")) 

p1_interactif <- ggplotly(p1)

# Afficher le graphique interactif
p1_interactif 
```

```{r echo=FALSE}
subplot(
  p1_interactif, p_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Gênes ressenties en fonction de la catégorie de dysfonctionnement",
      font = list(size = 15, color = "black", family = "Arial", face = "bold")
    
    ),
    annotations = list(
      list(
        x = 0.2, y = 1.05, text = "Pour 835 dysfonctionnements", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "#1f77b4", family = "Arial", weight = "bold")
      ),
      list(
        x = 0.8, y = 1.05, text = "Sur le même niveau", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "#1f77b4", family = "Arial", weight = "bold")
      )
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1)))
```

```{r include=FALSE }
indice_colonne <- which(names(data) == "GENE_PROBLEMES_A1")
print(indice_colonne) # 106

indice_colonne <- which(names(data) == "REPARATION_A1")
print(indice_colonne) # 81

indice_colonne <- which(names(data) == "GENE_PROBLEMES_A25")
print(indice_colonne) # 80

indice_colonne <- which(names(data) == "REPARATION_A25")
print(indice_colonne) #105

81-31

```
