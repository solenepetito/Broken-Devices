---
title: 'Project : Broken devices Synthèse'
author: "Solène PETITO"
output:
  html_document: default
  pdf_document: default
  word_document: default
date: "2024-08-05"
editor_options: 
  markdown: 
    wrap: 72
---

# **SEMAINE DU 5 AOÛT 2024 au 10 AOÛT 2024 :**

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Cette commande permet de se mettre directement dans le dossier du fichier 
getwd()
```

```{r include=FALSE}
############### MODULE 1 : Chargement des librairies

library(openxlsx)
library(readxl)
library(ggplot2)
library(stringr)
library(tibble)
library(dplyr)
library(plotly) # permet de faire des graphes intéractifs
library(corrplot) # permet de réqliser des matrices de corrélation
library(tidyr)
library(RColorBrewer) # librairie pour les palettes de couleurs
library(viridis) # palette de couleurs > 25 nuances
library(Polychrome)
library(gridExtra) # afficher les graphes côte à côte
library(grid)

# Version de chaque libraries 

packageVersion("openxlsx") # 4.2.5.2
packageVersion("readxl") # 1.4.3
packageVersion("ggplot2") # 3.4.4
packageVersion("stringr") # 1.5.0
packageVersion("tibble") # 3.2.1
packageVersion("dplyr") # 1.1.3
packageVersion("plotly") # 4.10.4
packageVersion("corrplot") # 0.92
packageVersion("tidyr") # 1.3.0
packageVersion("RColorBrewer") # 1.1.3
packageVersion("gridExtra") # 2.3
packageVersion("grid") # 4.3.1


```

```{r include=FALSE}
# Création d'une fonction **Count_VCM** (VCM = Variable à choix multiples) permettant d'afficher pour les variables à choix multiples UNIQUEMENT, le nombre de fois où chaque modalité est renseignée dans toute la colonne. Elle prend en entrée une variable à choix multiple (*variable*), issue de la base de données, et son nombre total de modalités (*nb_de_modalites*), et renvoit une matrice indiquant en ligne 1 le numéro de la modalité, et en ligne 2 le nombre de fois où les répondants l'on choisit.

Count_VCM <- function(variable,nb_de_modalites){
  mat <- matrix(0,nrow=2,ncol=nb_de_modalites)
  mat[1,]=c(1:nb_de_modalites)
  for (i in 1:length(variable)){
    ligne=str_extract_all(variable[i],".{2}")[[1]]
    vec=sub("^0+","",ligne)
    for (j in 1:length(vec)){
      for (k in 1:ncol(mat)){
        if (vec[j]==mat[1,k]){
          mat[2,k]=mat[2,k]+data[i,"poids"] # mettre "+1" à la place de "data[i,"poids"]" si on ne concidère pas les poids
        }
      }
    }
  }
  return(mat)
}

##########################################

# Pour éviter d'avoir à afficher les numéros des modalités sur chaques graphes, je stocke directement les libellés des modalités dans des vecteurs

label_RIDENTIFICATION_PROBLEME = c("Problème avec l’écran","Problème de sensibilité du tactile","Problème avec l’appareil photo","Problème avec la lampe torche ou le flash","Problème avec le GPS","Problème avec le micro","Problème de son","Problème de prise jack","Problème de chargement","Problème de batterie","Problème de Wi-Fi","Problème de capteurs","Problème de Bluetooth ou de transferts de fichiers sans fil","Problème de téléphonie","Problème d’accès à Internet","Problème avec les boutons","Problème de vibreur","Stockage saturé","Système d’exploitation non mis à jour","Applications ne pouvant pas être téléchargées ou mises à jour","Problème lié à une fonctionnalité manquante","Fonctionnalité qui ne marche plus","Dysfonctionnement logiciel","Problèmes avec des applications","Problème de lenteur","Autre")

label_ACQUISITION = c("Quelqu’un me l’a offert ou donné","Quelqu’un me l’a prêté","Je l’ai acheté","Je l’ai obtenu dans le cadre de mon contrat avec mon opérateur","Mon employeur me l’a fourni","Je l’ai loué","Je ne me souviens pas","Obtenu par un autre moyen")

label_COHABITATION = c("Dès que j’ai décelé le dysfonctionnement","Moins d’un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de deux ans","Je ne sais pas" )

label_GENE=c("Très gênant","Plutôt gênant","Plutôt pas gênant","Pas gênant du tout")

label_INT_REPARATION= c("Oui, par moi-même","Oui, par le SAV ou un réparateur","Oui, par une connaissance","Pas pour l’instant", "Non")

label_RECENCE <- c("Dès la première utilisation","En moins de 3 mois","Entre 3 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Plus de 3 ans","Je ne sais pas")

label_REPARATION <- c("Oui et le problème est resolu","Oui mais le problème na pas pu être résolu","Non, le problème s’est résolu tout seul au bout d’un moment","Non, peut être plus tard","Non, je ne pense pas tenter de résoudre le problème")

label_OS <- c("IOS (Apple)","Android","Autre","Je ne sais pas")

label_ETAT= c("Neuf","D'occasion","Reconditionné","Je ne sais pas" )

label_COHAB_2 <- c("Moins d'un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de 2 ans")

label_RAISON_UTIL_PB <- c("Cela serait trop coûteux de résoudre le(s) problème(s) ou de remplacer mon smartphone",
"J’attends une opportunité", "Je ne peux pas résoudre le problème car le smartphone ne m’appartient pas","Je ne sais pas comment résoudre le(s) problème(s)","Je veux faire durer mon téléphone le plus longtemps possible","Ce(s) problème(s) ne m’impacte(nt) pas tant que ça au quotidien","Je n’ai pas pris le temps de m’en occuper, de chercher une solution","Mon téléphone est trop récent pour que je le fasse réparer ou que je le remplace","La résolution du (ou des) problème(s) est trop difficile ou incertaine","Ça me donne un prétexte pour moins l’utiliser","Cela ne vaut pas la peine de résoudre le(s) problème(s)","Mon smartphone a une particularité difficile à retrouver si je devais le remplacer","Autre")

label_IMPACT <- c("Usage global du smartphone","Communication ","Réseaux sociaux ","Cartes et guidage GPS","Jeux","Navigation web","Streaming musique et vidéo","Outils de productivité ","Logiciels et applications professionnelles dédiées","Photo, vidéo et autres activités de création","Identification bancaire, paiement sans contact","Tickets dématérialisés ","Courses et achats en ligne","Autre","Aucun")
```

```{r include=FALSE}
# Catégorisation des dysfonctionnements

label_dys <- c("Stockage","Matériel","Mise à jour","Dys divers")

materiel <- c(1,2,1,3,4,6,7,8,9,10,12,16,17)
dys_divers <- c(5,11,13,14,15,21,22,23,24,25)
stockage <- c(18)
maj <- c(19,20)

# Trouver la liste qui contient le plus d'éléments pour après définir le nombre de colonnes de notre matrice
max_length <- max(length(materiel), length(dys_divers), length(stockage), length(maj))

# Initialiser la matrice avec des zéros
matrice_cat <- matrix(0, nrow = 4, ncol = max_length)

# Remplir les lignes de la matrice avec les listes
matrice_cat[1, 1:length(stockage)] <- stockage
matrice_cat[2, 1:length(materiel)] <- materiel
matrice_cat[3, 1:length(maj)] <- maj
matrice_cat[4, 1:length(dys_divers)] <- dys_divers

# Afficher la matrice
print

```

```{r include=FALSE}
# Import des données

########## Pour la commande qui suit indiquer le chemin où se trouve le dossier data
setwd("/home/solene_petito/Bureau/Stage/Broken_devices")

data <- readRDS("data/data1.rds") # base de données sur laquelle on va appliquer tous les changements

# Exporter la base de données en format Excel
write.xlsx(data, file = "data/database.xlsx")

Broken_Devices_Data <- read.csv("data/Broken-Devices-Data1-xlsx.csv",row.names=1) # base de données initiale sur laquelle on pourra se référer pour voir si les chgts ont bien été appliqués

# nombre d'observations
nb_obs <- nrow(data) # 968 

# nombre de variables 
nb_var <- ncol(data) # 164
```

Questions pour lesquelles on attend des réponses : 

Quel pourcentage de la population française vit avec un smartphone endommagé ? et depuis combien de temps ? • Quel est l'impact des dommages sur l'utilisation ? • Quand l'appareil a-t-il été endommagé après l'achat ? • Quels types de dommages sont les plus répandus ? • Quel est l'impact fonctionnel de ces dommages ? • Combien de temps s'écoule entre les dommages et le changement de smartphone ? • Quelles actions les répondants ont-ils entreprises (réparation, achat, acceptation, ...)

### **I ) Quel pourcentage de la population française vit avec un smartphone endommagé ?**

C'est 42 % de la population française qui vit avec un smartphone endommagé : sur nos 47831 individus, 19889 recontrent au mois un dysfonctionnement sur leur smartphone actuel, soit 42% des individus.

```{r include=FALSE}
# nb de personnes dans la base 
n = floor(sum(data$poids)) # 47831
print(n)

# nb de personnes qui rencontrent un dys
don <- data[data$RIDENTIFICATION_PROBLEMES!="27",c("RIDENTIFICATION_PROBLEMES","poids")]
n_dys = floor(sum(don$poids)) # 19889
print(n_dys)

# pourcentage de personnes qui rencontrent un dys 

pourcent_dys = round(n_dys*100/n) # 42%
print(pourcent_dys)
```

### **II ) Et depuis combien de temps ?**

En moyenne les gens cohabitent avec le ou les dysfonctionnement(s) entre 1 et 6 mois. 

```{r include=FALSE}
### Création d'un dataframe avec 4 colonnes : le numéro du dys, la catégorie du dys, le degre de gêne du dys et le temps de cohabitation du dys :

# dys qui ont tenté d'être résoud ou qui ont été résolus

pbs = c()
cate_dys = c()
deg_gene = c()
cohab = c()
poids = c()

df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27" & data$RIDENTIFICATION_PROBLEMES != "26"),]
variable = df$RIDENTIFICATION_PROBLEMES

for (i in 1:length(variable)){
  liste_pbs =str_extract_all(variable[i], ".{2}")[[1]]
  liste_pbs = as.numeric(liste_pbs)
  for (j in 1:length(liste_pbs)){
    pb = liste_pbs[j]
    num=as.character(pb)
    g=paste0("GENE_PROBLEMES_A",num)
    gene=df[i,g]
    c= paste0("COHABITATION_DYSFONCTION_A",num)
    coha = df[i,c]
    if(!is.null(gene) && !is.na(gene) && !is.null(coha) && !is.na(coha)){
      
      result <- which(matrice_cat == pb, arr.ind = TRUE)
      cat <- result[1]
      poid = df[i,"poids"]
      pbs = c(pbs,pb)
      cate_dys = c(cate_dys,cat)
      deg_gene = c(deg_gene,gene)
      cohab = c(cohab,coha)
      poids = c(poids,poid)
        }
  }
}

#print(head(pbs))
#print(head(cate_dys))
#print(head(deg_gene))
#print((head(cohab)))

print(length(pbs))
print(length(cate_dys))
print(length(deg_gene))
print(length(cohab))



don = data.frame()
don <- data.frame( "Categorie_dys"=cate_dys, "Gêne"=deg_gene,"Cohab"=cohab, Poids = poids)
don[which(don$Cohab==1),"Cohab"]=2 # On lie les "moins d'un mois" et les "dès que j'ai décelé le dys" ensemble
print(head(don))
print(nrow(don))
```

```{r include=FALSE}
# Temps de cohabt=itation des personnes n'ayant pas résolu le ou les dysfonctionnements rencontrés

COHAB_non_resolus <- c( 3, 2, 3, 4, 4, 4, 3, 3, 3, 4, 4, 4, 3, 4, 3, 4, 1, 3, 3, 2, 2, 4, 4, 3, 4, 4, 2, 3, 4, 3, 3, 4, 3, 4, 3, 2, 3, 1, 3, 4, 2, 2, 3, 3, 4, 4, 3, 2, 4,2, 3, 3, 3, 2, 3, 3, 3, 4, 3, 4, 2, 3, 3, 2, 4, 4, 3, 4, 2, 4, 3, 4, 3, 3, 3, 4, 2, 3, 4, 3, 3, 4, 3, 4, 4, 4, 4, 4, 2, 3, 2, 2, 4, 3, 3, 2, 3, 3,4, 4, 3, 2, 3, 4, 4, 3, 3, 4, 3, 3, 3, 4, 4, 2, 4, 4, 2, 4, 3, 4, 4, 3, 3, 4, 4, 4, 3, 4, 2, 3, 1, 2, 4, 3, 3, 4, 4, 3, 4, 3, 3, 4, 4, 4, 3, 4, 3,3, 4, 3, 4, 2, 2, 3, 3, 1, 2, 3, 2, 3, 3, 4, 4, 3, 4, 3, 3, 4, 4, 4, 3, 3, 2, 4, 3, 1, 2, 3, 4, 2, 4, 3, 4, 4, 4, 3, 3, 4, 3, 3, 2, 3, 2, 4, 4, 4,3, 4, 3, 3, 1, 3, 2, 4, 4, 3, 2, 4, 3, 4, 3, 4, 3, 4, 4, 4, 3, 4, 3, 3, 2, 4, 3, 3, 4, 2, 2, 4, 3, 3, 3, 4, 1, 4, 4, 4, 3, 3, 4, 3, 4, 2, 3, 4, 3,4,3 ,4 ,4 ,4 ,4 ,4, 3, 4, 3, 4, 2, 3, 4, 3, 3, 3, 3, 4, 4, 2, 4, 4, 4, 3, 2, 3, 4, 4, 4, 3, 3, 2, 3, 4, 3, 4, 4, 4, 3, 2, 4, 4, 1, 3, 2, 4, 4, 3,2, 4, 4, 3, 4, 4, 4, 4, 3, 2, 4, 3, 4, 4, 3, 4, 3, 1, 3, 3, 2, 3)

nb_non_resolus <- length(COHAB_non_resolus) # 316
```

```{r include=FALSE}
# dys qui  n'ont pas été résolus

# Initialisation des vecteurs pour stocker les valeurs de recence, année, et mois
recence <- c()
annee <- c()
mois <- c()
gene <- c()
pbs = c()
cate_dys = c()
poids = c()


# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105 (indice des colonnes reparation)
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 4 || val == 5)) {
      RECENCE <- df[j, i - 25]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(RECENCE)) {
        recence <- c(recence, RECENCE)
        annee <- c(annee, df[j, "DATEOBTENTIONSMART_1"])
        mois <- c(mois, df[j, "DATEOBTENTIONSMART_2"])
        gene <- c(gene,df[j, i - 50])
        result <- which(matrice_cat == (i-80), arr.ind = TRUE)
        cat <- result[1]
        pbs = c(pbs,i-80)
        poid = df[i,"poids"]
        cate_dys = c(cate_dys,cat)
        poids = c(poids,poid)
      }
    }
  }
}

# Suppression de la raison 7 dans la liste recence 

indices_rec_7= which(recence==7)
gene=gene[-c(indices_rec_7)]
pbs=pbs[-c(indices_rec_7)]
cate_dys=cate_dys[-c(indices_rec_7)]
poids = poids[-c(indices_rec_7)]

don2 <- data.frame( "Categorie_dys"=cate_dys, "Gêne"=gene,"Cohab"=COHAB_non_resolus+1,Poids = poids)

# Afficher les résultats pour vérifier
print(head(pbs))
print(head(cate_dys))
print(head(gene))

# Jointure des dataframe entre eux 
don <- rbind(don,don2)

# Création d'un autre dataframe pour une future jointure 
don1 <- rbind(don,don2)

head(don)
nrow(don)
nrow(don2)
```


```{r include=FALSE}
# Calcul du temps de cohabitation moyen 

table_ponderee <- xtabs(Poids ~ Cohab, data = don)

# Afficher la table pondérée
print(table_ponderee)

label_COHABITATION = c("Dès que j’ai décelé le dysfonctionnement","Moins d’un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de deux ans","Je ne sais pas" )

freq = table(don$Cohab)

vec1 = as.numeric(names(table_ponderee))
vec2 = as.numeric(table_ponderee)

moyenne = round(sum(vec1*vec2)/sum(vec2))

print(label_COHABITATION[moyenne])

```

```{r echo=FALSE}
# Répartition des différents temps de cohabitation avec le nombre de personnes pour chacun d'eux dans un dataframe

df = data.frame(Cohabitation = label_COHABITATION[2:6],Nb_dys=round(vec2), Pourcent = round(vec2*100/sum(vec2)))
df

```

Différentes Représentations graphiques du temps de cohabitation :

```{r echo=FALSE}
df <- data.frame(Cohabitation = factor(label_COHABITATION[2:5],levels=label_COHABITATION),valeurs=round(vec2[1:4]),
  start = c(0, 1, 6, 24),  # Début de l'intervalle en mois
  end = c(1, 6, 24, 48)    # Fin de l'intervalle en mois (Inf pour plus de 2 ans)
)

ggplot(df) +
  geom_tile(aes(x = (start + end) / 2, y = 0, width = end - start, height = valeurs, fill = Cohabitation)) +
  scale_x_continuous(breaks = seq(0, 48, by = 6), limits = c(0, 48)) +  # Ajuster les limites et les breaks de l'axe des x
  labs(title = "Répartition des temps de cohabitation",
       x = "Durée (mois)",
       y = "Valeurs") +
  theme_minimal() +
  scale_fill_brewer(palette = "Greens", name = "Temps de cohabitation")+
  theme(plot.title = element_text(hjust = 0.5, face = "bold",colour="palegreen3"),
        axis.title.x = element_text( face = "bold",colour="palegreen3"),
        axis.title.y = element_text(face = "bold",colour="palegreen3")) + scale_y_continuous(labels = function(x) abs(x), breaks = seq(-8000, 8000, by = 2000))
```

```{r echo=FALSE}
df <- data.frame(
  Cohabitation = factor(label_COHABITATION[2:5], levels = label_COHABITATION),
  valeurs = round(vec2[1:4]),
  start = c(0, 1, 6, 24),  # Début de l'intervalle en mois
  end = c(1, 6, 24, 48)    # Fin de l'intervalle en mois (Inf pour plus de 2 ans)
)

# Ajouter un point supplémentaire pour prolonger la ligne jusqu'à 48 mois
df <- rbind(df, data.frame(
  Cohabitation = tail(df$Cohabitation, 1),  # Garder la dernière catégorie de cohabitation
  valeurs = tail(df$valeurs, 1),            # Garder la dernière valeur
  start = 48,                               # Mois 24
  end = 48                                  # Mois 48
))

 p <- ggplot(df) +
  geom_line(aes(x = start, y = valeurs), linewidth = 1.5, color = "palegreen3") +  # Tracer une ligne continue sans changer de couleur
  scale_x_continuous(breaks = seq(0, 48, by = 6), limits = c(0, 48)) +  # Ajuster les limites et les intervalles de l'axe des x
  scale_y_continuous(
    limits = c(0, 13000),           # Définir les limites de l'axe des ordonnées (par exemple, de 0 à 100)
    breaks = seq(0, 13000, by = 2000), # Définir les intervalles des étiquettes (par exemple, tous les 20)
    expand = c(0, 0)               # Enlever l'espacement autour des données
  ) +
  geom_point(aes(x = start, y = valeurs), size = 1.5, color = "darkgreen") +
  # Ajuster les limites et les intervalles de l'axe des y
  labs(
    title = "Répartition des temps de cohabitation",
    x = "Durée (mois)",
    y = "Nombre de dysfonctionnements"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", colour = "palegreen3"),
    axis.title.x = element_text(face = "bold", colour = "palegreen3"),
    axis.title.y = element_text(face = "bold", colour = "palegreen3")
  )
 
p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif 

```



### **III ) Quand l'appareil a-t-il été endommagé après l'achat ?**

En moyenne l'appareil a été endommagé entre 1 an et 2 ans après l'achat. 

```{r include=FALSE}
label_RECENCE <- c("Dès la première utilisation","En moins de 3 mois","Entre 3 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Plus de 3 ans","Je ne sais pas")

colonne_deb <- which(names(data) == "RECENCE_PROBLEMES_A1") # 56

colonne_fin <- which(names(data) == "RECENCE_PROBLEMES_A25") # 80

matrice = matrix(0,nrow=1,ncol=length(label_RECENCE))

don <- data[data$RIDENTIFICATION_PROBLEMES!="26" & data$RIDENTIFICATION_PROBLEMES!="27", ]

for (i in colonne_deb:colonne_fin){
  for (j in 1:nrow(don)){
  recence = don[j,i]
  if (!is.null(recence) && !is.na(recence)){
    matrice[1,recence]=matrice[1,recence] + floor(don[j,"poids"])
  }
  }
}

vec = 1:ncol(matrice)
moyenne <- round(sum(vec*matrice[1,])/sum(matrice[1,]))
 
print(label_RECENCE[moyenne]) # "Entre 1 et 2 ans"

```

```{r echo=FALSE}
# Répartition des différents temps de recence avec le nombre de personnes pour chacun d'eux

df = data.frame(Recence_dys= label_RECENCE[vec],Nb_dys = matrice[1,], Pourcent = round( matrice[1,]*100/sum(matrice[1,])))

df
```

```{r echo=FALSE}
# Nouvelles données
label_COHABITATION <- c("Dès la première utilisation", "En moins de 3 mois", "Entre 3 mois et 1 an", "Entre 1 et 2 ans", "Entre 2 et 3 ans", "Plus de 3 ans")
valeurs <- c(3363, 7824, 9750, 9684, 5344, 3251)
start <- c(0, 1, 3, 12, 24, 36)  # Début de l'intervalle en mois
end <- c(1, 3, 12, 24, 36, 48)   # Fin de l'intervalle en mois (Inf pour plus de 2 ans)

# Créer le DataFrame
df <- data.frame(
  Cohabitation = factor(label_COHABITATION, levels = label_COHABITATION),
  valeurs = valeurs,
  start = start,
  end = end
)

# Ajouter un point supplémentaire pour prolonger la ligne jusqu'à 48 mois
df <- rbind(df, data.frame(
  Cohabitation = tail(df$Cohabitation, 1),  # Garder la dernière catégorie de cohabitation
  valeurs = tail(df$valeurs, 1),            # Garder la dernière valeur
  start = 48,                               # Mois 48
  end = 48                                  # Mois 48
))


p <- ggplot(df) +
  geom_line(aes(x = start, y = valeurs), linewidth = 1.5, color = "palegreen3") +  # Tracer une ligne continue
  scale_x_continuous(breaks = seq(0, 48, by = 3), limits = c(0, 48)) +  # Ajuster les limites et les intervalles de l'axe des x
  scale_y_continuous(
    limits = c(0, 13000),           # Définir les limites de l'axe des ordonnées
    breaks = seq(0, 13000, by = 2000), # Définir les intervalles des étiquettes (par exemple, tous les 2000)
    expand = c(0, 0)               # Enlever l'espacement autour des données
  ) + 
  geom_point(aes(x = start, y = valeurs), size = 1.5, color = "darkgreen") +  # Ajouter des points sur la ligne
  labs(
    title = "Quand l'appareil a-t-il été endommagé après l'achat ? ",
    x = "Durée (mois)",
    y = "Nombre de dysfonctionnements"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", colour = "palegreen3"),
    axis.title.x = element_text(face = "bold", colour = "palegreen3"),
    axis.title.y = element_text(face = "bold", colour = "palegreen3")
  )
# Rendre le graphique interactif avec Plotly
p_interactif <- ggplotly(p)

# Afficher le graphique interactif
p_interactif


```



### **IV ) Quels types de dommages sont les plus répandus ?**

Les problèmes qui sont les plus répandus sont les problèmes de batteries ( concernent 29% des personnes qui rencontrent un dysfonctionnement), suivis du sotkcage saturé (23%), suivi des problèmes de lenteur (21%).

```{r echo=FALSE}
variable = data$RIDENTIFICATION_PROBLEMES
nb_de_modalites = 26

res = Count_VCM(variable,nb_de_modalites)

df = data.frame(Dysfonctionnement = label_RIDENTIFICATION_PROBLEME, Valeurs = round(res[2,]), Pourcentage = round(res[2,]*100/sum(data[data$RIDENTIFICATION_PROBLEMES!="26" & data$RIDENTIFICATION_PROBLEMES!="27","poids" ])))

df <- df %>% 
  arrange(desc(Valeurs))

df


```

### **V ) Quel est l'impact fonctionnel de ces dommages ?**

Les dommages en question ont surtout un impact sur la navigation web (12% des dysfonctionnements rencontrés), sur l'usage global du smartphone (11.5%) et sur les jeux (11%).

```{r echo=FALSE}
label_IMPACT <- c("Usage global du smartphone","Communication ","Réseaux sociaux ","Cartes et guidage GPS","Jeux","Navigation web","Streaming musique et vidéo","Outils de productivité ","Logiciels et applications professionnelles dédiées","Photo, vidéo et autres activités de création","Identification bancaire, paiement sans contact","Tickets dématérialisés ","Courses et achats en ligne","Autre","Aucun")

var = data[data$RIMPACT_PB!="","RIMPACT_PB"]

res <- Count_VCM(var,length(label_IMPACT))

df = data.frame(Impact = label_IMPACT, Valeurs = round(res[2,]), Pourcentage = round(res[2,]*100/sum(res[2,]),2))

# sum(res[2,]) = 806

df <- df %>% 
  arrange(desc(Valeurs))

head(df)

```

### **VI ) Combien de temps s'écoule entre les dommages et le changement de smartphone ?**

En moyenne, il s'écoule deux entre les dommages et le changement de smartphone. Les personnes ayant réparé ou tenté de réparer leur téléphone mettent 7 mois à 2 ans à remplacer leur téléphone et les personnes na'ayant pas réparer mettent entre 1 an et 2 ans à le remplacer.

```{r include=FALSE}

# Ceux qui n'ont pas réparé 

# Initialisation des vecteurs pour stocker les valeurs de recence, année, et mois
recence <- c()
annee <- c()
mois <- c()
remplacement1 = c()
poids1 = c()

# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 4 || val == 5)) {
      RECENCE <- df[j, i - 25]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(RECENCE)) {
        recence <- c(recence, RECENCE)
        annee <- c(annee, df[j, "DATEOBTENTIONSMART_1"])
        mois <- c(mois, df[j, "DATEOBTENTIONSMART_2"])
        remplacement1 = c(remplacement1,df[j,"INTENTION_REMPLACEMENT"])
        poids1 = c(poids1,df[i,"poids"])
      }
    }
  }
}

# Suppression de la raison 7 dans la liste recence 

indices_rec_7= which(recence==7)
recence=recence[-c(indices_rec_7)]
annee=annee[-c(indices_rec_7)]
mois=mois[-c(indices_rec_7)]
poids1 = poids1[-c(indices_rec_7)]
remplacement1=remplacement1[-c(indices_rec_7)]

# Afficher les résultats pour vérifier
print(head(recence))
print(head(annee))
print(head(mois))

```

```{r include=FALSE}
COHAB_non_resolus <- c( 3, 2, 3, 4, 4, 4, 3, 3, 3, 4, 4, 4, 3, 4, 3, 4, 1, 3, 3, 2, 2, 4, 4, 3, 4, 4, 2, 3, 4, 3, 3, 4, 3, 4, 3, 2, 3, 1, 3, 4, 2, 2, 3, 3, 4, 4, 3, 2, 4,2, 3, 3, 3, 2, 3, 3, 3, 4, 3, 4, 2, 3, 3, 2, 4, 4, 3, 4, 2, 4, 3, 4, 3, 3, 3, 4, 2, 3, 4, 3, 3, 4, 3, 4, 4, 4, 4, 4, 2, 3, 2, 2, 4, 3, 3, 2, 3, 3,4, 4, 3, 2, 3, 4, 4, 3, 3, 4, 3, 3, 3, 4, 4, 2, 4, 4, 2, 4, 3, 4, 4, 3, 3, 4, 4, 4, 3, 4, 2, 3, 1, 2, 4, 3, 3, 4, 4, 3, 4, 3, 3, 4, 4, 4, 3, 4, 3,3, 4, 3, 4, 2, 2, 3, 3, 1, 2, 3, 2, 3, 3, 4, 4, 3, 4, 3, 3, 4, 4, 4, 3, 3, 2, 4, 3, 1, 2, 3, 4, 2, 4, 3, 4, 4, 4, 3, 3, 4, 3, 3, 2, 3, 2, 4, 4, 4,3, 4, 3, 3, 1, 3, 2, 4, 4, 3, 2, 4, 3, 4, 3, 4, 3, 4, 4, 4, 3, 4, 3, 3, 2, 4, 3, 3, 4, 2, 2, 4, 3, 3, 3, 4, 1, 4, 4, 4, 3, 3, 4, 3, 4, 2, 3, 4, 3,4,3 ,4 ,4 ,4 ,4 ,4, 3, 4, 3, 4, 2, 3, 4, 3, 3, 3, 3, 4, 4, 2, 4, 4, 4, 3, 2, 3, 4, 4, 4, 3, 3, 2, 3, 4, 3, 4, 4, 4, 3, 2, 4, 4, 1, 3, 2, 4, 4, 3,2, 4, 4, 3, 4, 4, 4, 4, 3, 2, 4, 3, 4, 4, 3, 4, 3, 1, 3, 3, 2, 3)
```


```{r include=FALSE}
# on enleve les individus qui ont indiqué ne pas savoir quand est ce qu'il comptait remplacé leur téléphone et ceux aussi qui ont indiqué qu'ils ne voulait pas le remplacer

indices_remplacement_6_7= which(remplacement1==7 | remplacement1==6)
recence=recence[-c(indices_remplacement_6_7)]
annee=annee[-c(indices_remplacement_6_7)]
mois=mois[-c(indices_remplacement_6_7)]
COHAB_non_resolus=COHAB_non_resolus[-c(indices_remplacement_6_7)] 
poids1 = poids1[-c(indices_remplacement_6_7)]
remplacement1=remplacement1[-c(indices_remplacement_6_7)]


```

```{r include=FALSE}
remplacement1 
COHAB_non_resolus
```

```{r include=FALSE}
label = c("moins d'un mois","entre 2 mois et 7 mois","entre 2 mois et 2 ans","entre 7 mois et 2 ans","Plus de 2 ans","entre 1 an et 2 ans","entre 1 an et 3 ans","entre 1 an et 4 ans","Plus de 3 ans","Plus de 4 ans")

liste = c(1,2,4,6,5,2,3,4,7,5,4,4,7,8,5,5,5,5,9,10)
matrice = matrix(liste,nrow=4,ncol=5,byrow=TRUE)
matrice 
```

```{r include=FALSE}
cohab_remplacement = c()
for (i in 1:length(remplacement1)){
  cohab = COHAB_non_resolus[i]
  remp = remplacement1[i]
  val = matrice[cohab,remp]
  cohab_remplacement=c(cohab_remplacement,val)
}

moy = round(mean(cohab_remplacement))
label[moy]
```

```{r include=FALSE}
# Ceux qui ont réparé 

COHAB <- c()
annee <- c()
mois <- c()
remplacement2 = c()
poids2 =c()

# Filtrer les données pour exclure les problèmes identifiés avec le code "27"
df <- data[which(data$RIDENTIFICATION_PROBLEMES != "27"),]

# Parcourir les colonnes de 81 à 105
for (i in 81:105) {
  # Parcourir les lignes du dataframe filtré
  for (j in 1:nrow(df)) {
    val <- df[j, i]
    # Vérifier si la valeur n'est pas NA avant de vérifier si elle est 4 ou 5
    if (!is.na(val) && (val == 1 || val == 2 )) {
      COH <- df[j, i + 25]
      # Vérifier si RECENCE n'est pas NA et val n'est pas NULL
      if (!is.na(COH)) {
        COHAB <- c(COHAB, COH)
        annee <- c(annee, df[j, "DATEOBTENTIONSMART_1"])
        mois <- c(mois, df[j, "DATEOBTENTIONSMART_2"])
        remplacement2 = c(remplacement2,df[j,"INTENTION_REMPLACEMENT"])
        poids2 = c(poids2,df[i,"poids"])
      }
    }
  }
}

# Suppression de la raison 6 dans la liste COHABITATION 

indices_rec_7= which(COHAB==6)
COHAB=COHAB[-c(indices_rec_7)]
annee=annee[-c(indices_rec_7)]
mois=mois[-c(indices_rec_7)]
remplacement2=remplacement2[-c(indices_rec_7)]
poids2 = poids2[-c(indices_rec_7)]

# Afficher les résultats pour vérifier
print(head(COHAB))
print(head(annee))
print(head(mois))

```



```{r include=FALSE}
# on enleve les individus qui ont indiqué ne pas savoir quand est ce qu'il comptait remplacé leur téléphone et ceux aussi qui ont indiqué qu'ils ne voulait pas le remplacer

indices_remplacement_6_7= which(remplacement2==7 | remplacement2==6)
annee=annee[-c(indices_remplacement_6_7)]
mois=mois[-c(indices_remplacement_6_7)]
COHAB=COHAB[-c(indices_remplacement_6_7)] 
poids2 = poids2[-c(indices_remplacement_6_7)]
remplacement2=remplacement2[-c(indices_remplacement_6_7)]

```


```{r include=FALSE}
remplacement2 
COHAB
```

```{r include=FALSE}
# On remplace la valeur 1 de COHAB par la valeur 2

COHAB[which(COHAB==1)]=2
```

```{r include=FALSE}
COHAB
```


```{r include=FALSE}
label = c("moins d'un mois","entre 2 mois et 7 mois","entre 2 mois et 2 ans","entre 7 mois et 2 ans","Plus de 2 ans","entre 1 an et 2 ans","entre 1 an et 3 ans","entre 1 an et 4 ans","Plus de 3 ans","Plus de 4 ans")

liste = c(1,2,4,6,5,2,3,4,7,5,4,4,7,8,5,5,5,5,9,10)
matrice = matrix(liste,nrow=4,ncol=5,byrow=TRUE)
matrice 
```

```{r include=FALSE}
cohab_remplacement = c()
for (i in 1:length(remplacement2)){
  cohab = COHAB[i]
  remp = remplacement2[i]
  val = matrice[cohab-1,remp]
  cohab_remplacement=c(cohab_remplacement,val)
}

moy = round(mean(cohab_remplacement))
label[moy]
```

```{r include=FALSE}
# En liant tous le monde 

COHAB_fin = c(COHAB_non_resolus,COHAB-1)
remplacement_fin = c(remplacement1,remplacement2)
poids_fin = c(poids1,poids2)

cohab_remplacement = c()
for (i in 1:length(remplacement_fin)){
  cohab = COHAB_fin[i]
  remp = remplacement_fin[i]
  val = matrice[cohab,remp]
  cohab_remplacement=c(cohab_remplacement,val)
}

moy = round(mean(cohab_remplacement))
label[moy]
```


```{r echo=FALSE}
res = xtabs(poids_fin ~ cohab_remplacement)
vec1 = as.numeric(names(res))
vec2 = as.numeric(res)

df = data.frame(Temps_ecoule = label , Nb_dys = round(vec2),Pourcent = round(vec2*100/sum(vec2)))

df <- rbind(df[1:4, ], df[6:8, ], df[5, ], df[9:nrow(df), ])

df
```



```{r include=FALSE }
indice_colonne <- which(names(data) == "COHABITATION_DYSFONCTION_A1") 
print(indice_colonne) # 106

indice_colonne <- which(names(data) == "COHABITATION_DYSFONCTION_A25")
print(indice_colonne) # 81

indice_colonne <- which(names(data) == "REPARATION_A1")
print(indice_colonne) # 80

indice_colonne <- which(names(data) == "REPARATION_A25")
print(indice_colonne) #105

81-31


```
