---
title: 'Project : Broken devices S6'
author: "Solène PETITO"
output:
  html_document: default
  pdf_document: default
  word_document: default
date: "2024-07-01"
editor_options: 
  markdown: 
    wrap: 72
---

# **SEMAINE DU 8 JUILLET 2024 au 12 JUILLET 2024 :**

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
############### MODULE 1 : Chargement des librairies

library(readxl)
library(ggplot2)
library(stringr)
library(tibble)
library(dplyr)
library(plotly) # permet de faire des graphes intéractifs
library(corrplot) # permet de réqliser des matrices de corrélation
library(tidyr)
library(RColorBrewer) # librairie pour les palettes de couleurs
library(viridis) # palette de couleurs > 25 nuances
library(Polychrome)

```

```{r include=FALSE}
############### MODULE 2 : Création de fonctions

# fonction func1 qui prend en entrée un jeu de données (don) et le nom d'une colonne de type Cri (Caratère répétitive) de ce jeu de données (colonne), sous forme de chaine de caractères et sans préciser de numéro à la fin de celle-ci  : ex : "COHABITATION_DYSFONCTION_A" ou "GENE_PROBLEMES_A". Elle renvoit en sortie une matrice a 2 lignes et 25 colonnes, indiquant en ligne 1 le type de dysfonctionnement, et en ligne 2 une modalité moyenne calculée pour la variable donnée en entrée pour chaque type de dysfonctionnements.

func1 <- function (don,colonne){
  matrice <- matrix(0,nrow=2,ncol=25)
  matrice[1,] <- c(1:25)
  df = don[which(don$RIDENTIFICATION_PROBLEMES!="27"),]
  variable=df$RIDENTIFICATION_PROBLEMES
  for (pb in 1:25){
    vec=c()
    for (i in 1:length(variable)){
      ligne=str_extract_all(variable[i], ".{2}")[[1]]
      ligne=sub("^0+", "", ligne)
      if (pb %in% ligne){
        num=as.character(pb)
        nom_colonne=paste0(colonne,num)
        valeur=df[i,nom_colonne]
        if(!is.null(valeur) && !is.na(valeur)){
          vec=c(vec,valeur)
        }
      }
    }
    if (length(vec) > 0) {
    matrice[2, pb] <- round(mean(vec))
  } else {
    matrice[2, pb] <- 0
  }
  }
  return(matrice)
}
##########################################

# Création d'une fonction **Count_VCM** (VCM = Variable à choix multiples) permettant d'afficher pour les variables à choix multiples UNIQUEMENT, le nombre de fois où chaque modalité est renseignée dans toute la colonne. Elle prend en entrée une variable à choix multiple (*variable*), issue de la base de données, et son nombre total de modalités (*nb_de_modalites*), et renvoit une matrice indiquant en ligne 1 le numéro de la modalité, et en ligne 2 le nombre de fois où les répondants l'on choisit.

Count_VCM <- function(variable,nb_de_modalites){
  mat <- matrix(0,nrow=2,ncol=nb_de_modalites)
  mat[1,]=c(1:nb_de_modalites)
  for (i in 1:length(variable)){
    ligne=str_extract_all(variable[i],".{2}")[[1]]
    vec=sub("^0+","",ligne)
    for (j in 1:length(vec)){
      for (k in 1:ncol(mat)){
        if (vec[j]==mat[1,k]){
          mat[2,k]=mat[2,k]+1
        }
      }
    }
  }
  return(mat)
}

##########################################

# Pour éviter d'avoir à afficher les numéros des modalités sur chaques graphes, je stocke directement les libellés des modalités dans des vecteurs

label_RIDENTIFICATION_PROBLEME = c("Problème avec l’écran","Problème de sensibilité du tactile","Problème avec l’appareil photo","Problème avec la lampe torche ou le flash","Problème avec le GPS","Problème avec le micro","Problème de son","Problème de prise jack","Problème de chargement","Problème de batterie","Problème de Wi-Fi","Problème de capteurs","Problème de Bluetooth ou de transferts de fichiers sans fil","Problème de téléphonie","Problème d’accès à Internet","Problème avec les boutons","Problème de vibreur","Stockage saturé","Système d’exploitation non mis à jour","Applications ne pouvant pas être téléchargées ou mises à jour","Problème lié à une fonctionnalité manquante","Fonctionnalité qui ne marche plus","Dysfonctionnement logiciel","Problèmes avec des applications","Problème de lenteur","Autre")

label_ACQUISITION = c("Quelqu’un me l’a offert ou donné","Quelqu’un me l’a prêté","Je l’ai acheté","Je l’ai obtenu dans le cadre de mon contrat avec mon opérateur","Mon employeur me l’a fourni","Je l’ai loué","Je ne me souviens pas","Obtenu par un autre moyen")

label_COHABITATION = c("Dès que j’ai décelé le dysfonctionnement","Moins d’un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de deux ans","Je ne sais pas" )

label_GENE=c("Très gênant","Plutôt gênant","Plutôt pas gênant","Pas gênant du tout")

label_INT_REPARATION= c("Oui, par moi-même","Oui, par le SAV ou un réparateur","Oui, par une connaissance","Pas pour l’instant", "Non")

label_RECENCE <- c("Dès la première utilisation","En moins de 3 mois","Entre 3 mois et 1 an","Entre 1 et 2 ans","Entre 2 et 3 ans","Plus de 3 ans","Je ne sais pas")

label_REPARATION <- c("Oui et le problème est resolu","Oui mais le problème na pas pu être résolu","Non, le problème s’est résolu tout seul au bout d’un moment","Non, peut être plus tard","Non, je ne pense pas tenter de résoudre le problème")

label_OS <- c("IOS (Apple)","Android","Autre","Je ne sais pas")

label_ETAT= c("Neuf","D'occasion","Reconditionné","Je ne sais pas" )

label_COHAB_2 <- c("Moins d'un mois","Entre 1 et 6 mois","Entre 6 mois et 2 ans","Plus de 2 ans")

label_RAISON_UTIL_PB <- c("Cela serait trop coûteux de résoudre le(s) problème(s) ou de remplacer mon smartphone",
"J’attends une opportunité", "Je ne peux pas résoudre le problème car le smartphone ne m’appartient pas","Je ne sais pas comment résoudre le(s) problème(s)","Je veux faire durer mon téléphone le plus longtemps possible","Ce(s) problème(s) ne m’impacte(nt) pas tant que ça au quotidien","Je n’ai pas pris le temps de m’en occuper, de chercher une solution","Mon téléphone est trop récent pour que je le fasse réparer ou que je le remplace","La résolution du (ou des) problème(s) est trop difficile ou incertaine","Ça me donne un prétexte pour moins l’utiliser","Cela ne vaut pas la peine de résoudre le(s) problème(s)","Mon smartphone a une particularité difficile à retrouver si je devais le remplacer","Autre")

label_IMPACT <- c("Usage global du smartphone","Communication ","Réseaux sociaux ","Cartes et guidage GPS","Jeux","Navigation web","Streaming musique et vidéo","Outils de productivité ","Logiciels et applications professionnelles dédiées","Photo, vidéo et autres activités de création","Identification bancaire, paiement sans contact","Tickets dématérialisés ","Courses et achats en ligne","Autre","Aucun")

label_dys <- c("Stockage","Matériel","Mise à jour","Dys divers")
```

```{r include=FALSE}
# Catégorisation des dysfonctionnements

label_dys <- c("Stockage","Matériel","Mise à jour","Dys divers")

materiel <- c(1,2,1,3,4,6,7,8,9,10,12,16,17)
dys_divers <- c(5,11,13,14,15,21,22,23,24,25)
stockage <- c(18)
maj <- c(19,20)

# Trouver la liste qui contient le plus d'éléments pour après définir le nombre de colonnes de notre matrice
max_length <- max(length(materiel), length(dys_divers), length(stockage), length(maj))

# Initialiser la matrice avec des zéros
matrice_cat <- matrix(0, nrow = 4, ncol = max_length)

# Remplir les lignes de la matrice avec les listes
matrice_cat[1, 1:length(stockage)] <- stockage
matrice_cat[2, 1:length(materiel)] <- materiel
matrice_cat[3, 1:length(maj)] <- maj
matrice_cat[4, 1:length(dys_divers)] <- dys_divers

# Afficher la matrice
print(matrice_cat)
```



**OBJECTIF :** *Analyser la base de données*

## **ANALYSE DE LA BASE DE DONNÉES**

```{r include=FALSE}
# Import des données

data <- readRDS("/home/solene_petito/Bureau/Stage/Broken_devices/data/data1.rds") # base de données sur laquelle on va appliquer tous les changements

Broken_Devices_Data <- read.csv("/home/solene_petito/Bureau/Stage/Broken_devices/data/Broken-Devices-Data1-xlsx.csv",row.names=1) # base de données initiale sur laquelle on pourra se référer pour voir si les chgts ont bien été appliqués

# nombre d'observations
nb_obs <- nrow(data) # 968 

# nombre de variables 
nb_var <- ncol(data) # 164
```

```{r include=FALSE}
View(data)
View(Broken_Devices_Data)
```

### **I ) Problèmes rencontrés en fonction de l'OS**

Le graphe qui suit combine deux graphiques qui présentent les personnes ayant rencontré ou non des dysfonctionnements, et le système d'exploitation qu'ils possédaient : 

```{r include=FALSE}
res <- Count_VCM(data$RIDENTIFICATION_PROBLEMES,27)
Nb_personnes <- nrow(data) # 968 personnes
print(nrow(data))


sys = sort(unique(data$OS))
mat = matrix(0,nrow=3,ncol=length(sys))
mat[1,]=sys

for (i in 1:length(sys)){
  df=data[which(data$OS==i),]
  nb_ind = nrow(df)
  df2 = data[which(data$OS==i & data$RIDENTIFICATION_PROBLEMES!="27"),]
  nb_ind_pb=nrow(df2)
  mat[2,i]=nb_ind
  mat[3,i]=nb_ind_pb
}

dataframe <- data.frame("Sytèmes d'exploitation"=label_OS,"Nb_personnes"=mat[2,],"Nb_personnes_dys"=mat[3,],"Pourcentage_dys"=round(mat[3,]*100/mat[2,]))

print(dataframe)
```

```{r include=FALSE}
Categorie <- factor(label_OS, levels = label_OS)

df_T1 <- data.frame(OS = Categorie, valeurs = dataframe$Nb_personnes_dys, Légende = "Dysfonctionnement(s)")
df_T2 <- data.frame(OS = Categorie, valeurs = dataframe$Nb_personnes-dataframe$Nb_personnes_dys , Légende = "Pas de dysfonctionnements")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2)

# Créer un diagramme en barres empilées
p1 <- ggplot(df_combined, aes(x = OS, y = valeurs, fill = Légende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" so on veut des barres côtes à côtes
  labs(title = "Problèmes rencontrés en fonction de l'OS",
       x = "OS",
       y = "Nombre de personnes ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold",colour="#00868B"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="#00868B")) 

p1_interactif <- ggplotly(p1)

# Afficher le graphique interactif
p1_interactif 
```

```{r include=FALSE}
Categorie <- factor(label_OS, levels = label_OS)

df_T1 <- data.frame(OS = Categorie, valeurs = round(dataframe$Nb_personnes_dys*100/dataframe$Nb_personnes), Légende = "Dysfonctionnement(s)")
df_T2 <- data.frame(OS = Categorie, valeurs = round((dataframe$Nb_personnes-dataframe$Nb_personnes_dys)*100/dataframe$Nb_personnes), Légende = "Pas de dysfonctionnements")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2)

# Créer un diagramme en barres empilées
p2 <- ggplot(df_combined, aes(x = OS, y = valeurs, fill = Légende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" si on veut des barres côtes à côtes
  labs(title = "Problèmes rencontrés en fonction de l'OS",
       x = "OS",
       y = " Pourcentage de personnes ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold",colour="#00868B"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold",colour="#00868B")) 

p2_interactif <- ggplotly(p2)

# Afficher le graphique interactif
p2_interactif 
```

```{r echo=FALSE}
subplot(
  p1_interactif, p2_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Problèmes rencontrés en fonction de l'OS",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")
    ),
    annotations = list(
      list(
        x = 0.2, y = 1.05, text = "Sur 968 personnes", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "#00868B", family = "Arial", weight = "bold")
      ),
      list(
        x = 0.8, y = 1.05, text = "Sur le même niveau", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "#00868B", family = "Arial", weight = "bold")
      )
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1))   # Ajout de marge pour les titres
  )
```

Le premier graphe présente le nombre de personnes ayant rencontré ou non des dysfonctionnements, en fonction du système d'exploitation, et le deuxième graphe met tous les OS au même niveau, et représente le pourcentage de dysfonctionnements pour chacun d'eux.

### **II ) Problèmes rencontrés en fonction de l'année d'obtention**

La combinaison des deux graphiques suivants présentent les problèmes rencontrés en fonction des années d'obtention du smartphone (ici les 4 dernières années référencées) : 

```{r include=FALSE}
valeurs <- t(as.matrix(table(data$DATEOBTENTIONSMART_1)))
annees <- sort(unique(data$DATEOBTENTIONSMART_1))
nb_individus <- nrow(data)
mat=matrix(0,nrow=3,ncol=length(annees))
mat[1,]=annees
mat[2,]=valeurs
for (i in 1:length(annees)){
  df <- data[which(data$DATEOBTENTIONSMART_1==mat[1,i] & data$RIDENTIFICATION_PROBLEMES!="27"),]
  nb_avec_pbs=nrow(df)
  mat[3,i]=nb_avec_pbs

  
}
df <- data.frame("Année obtention"=mat[1,],"Nombre de personnes"=mat[2,],"Pourcentage de personnes avec pb"=round(mat[3,]*100/mat[2,]))

df <- df %>% 
  arrange(desc(Année.obtention))


print(df)
print(mat)
```

```{r include=FALSE}
df_T1 <- data.frame(Annee = mat[1,13:16], valeurs = mat[3,13:16 ], Légende = "Dysfonctionnements")
df_T2 <- data.frame(Annee = mat[1,13:16], valeurs = mat[2,13:16 ]-mat[3,13:16 ], Légende = "Pas de dysfonctionnements")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2)

# Créer un diagramme en barres empilées
p3 <- ggplot(df_combined, aes(x = Annee, y = valeurs, fill = Légende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" so on veut des barres côtes à côtes
  labs(title = "Problèmes rencontrés en fonction de l'année d'obtention",
       x = "Année d'obtention",
       y = "Nombre de personnes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold",colour="#00868B"), 
        axis.title.y = element_text(face = "bold",colour="#00868B")) 

p3_interactif <- ggplotly(p3)

# Afficher le graphique interactif
p3_interactif 
```

```{r include=FALSE}
df_T1 <- data.frame(Annee = mat[1,13:16], valeurs = round(mat[3,13:16 ]*100/mat[2,13:16]), Légende = "Dysfonctionnements")
df_T2 <- data.frame(Annee = mat[1,13:16], valeurs = round((mat[2,13:16 ]-mat[3,13:16 ])*100/mat[2,13:16]), Légende = "Pas de dysfonctionnements")

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2)

# Créer un diagramme en barres empilées
p4 <- ggplot(df_combined, aes(x = Annee, y = valeurs, fill = Légende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" so on veut des barres côtes à côtes
  labs(title = "Problèmes rencontrés en fonction de l'année d'obtention",
       x = "Année d'obtention",
       y = "Pourcentage de personnes (en %)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold",colour="#00868B"), 
        axis.title.y = element_text(face = "bold",colour="#00868B")) 

p4_interactif <- ggplotly(p4)

# Afficher le graphique interactif
p4_interactif 
```

```{r echo=FALSE}
subplot(
  p3_interactif, p4_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)
) %>%
  layout(
    title = list(
      text = "Problèmes rencontrés en fonction de l'année d'obtention",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")
    ),
    annotations = list(
      list(
        x = 0.2, y = 1.05, text = "Sur 845 personnes", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "#00868B", family = "Arial", weight = "bold")
      ),
      list(
        x = 0.8, y = 1.05, text = "Sur le même niveau", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "#00868B", family = "Arial", weight = "bold")
      )
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace
    xaxis = list(domain = c(0, 0.45)),  # Déplacer le premier graphique vers la gauche
    xaxis2 = list(domain = c(0.55, 1))   # Ajout de marge pour les titres
  )
```


Lien entre resolution et pourquoi ne pas avoir tenté de reparer : 
```{r}

REPARATION <- c(1:5)
matrice <- matrix(0,nrow=2,ncol=length(REPARATION))
matrice[1,] <- REPARATION
df=data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]
print(nrow(df))
for (i in 81:105){
    colonne=df[,i]
    for (j in 1:length(colonne)){
      num_REP <- df[j,i]
      raison <- df[j,"RRAISON_UTIL_PB_FORM"]
      if (!is.na(raison) && !is.na(raison) ){
        matrice[2,num_REP]=matrice[2,num_REP]+1
      }
    }
}

print(matrice)

```

```{r}
Count_VCM(data$RRAISON_UTIL_PB_FORM,13)
```

```{r}
mat_raison_cat = matrix(0,nrow=13,ncol=4)
mat2_raison_gene = matrix(0,nrow=13,ncol=4)

df = data[which(data$RIDENTIFICATION_PROBLEMES!="27"),]

for ( i in 81:105){
  for (j in 1:nrow(df)){
    res=df[j,i]
    if (!is.na(res) && (res == 4 || res == 5)){
      gene=df[j,i-50]
      num_pb=i-80
      result <- which(matrice_cat == num_pb, arr.ind = TRUE)
      cat <- result[1]
      liste = str_extract_all(df[j,"RRAISON_UTIL_PB_FORM"], ".{2}")[[1]]
      liste=as.numeric(liste)
      for (raison in liste){
        mat_raison_cat[raison,cat]=mat_raison_cat[raison,cat]+1
        mat2_raison_gene[raison,gene]=mat2_raison_gene[raison,gene]+1
      }
      
    }
    
  }
}

print(mat_raison_cat)
print(mat2_raison_gene)

```





Catégorisation + Résolution

```{r include=FALSE}
label_dys <- c("Stockage","Matériel","Mise à jour","Dys divers")

materiel <- c(1,2,1,3,4,6,7,8,9,10,12,16,17)
dys_divers <- c(5,11,13,14,15,21,22,23,24,25)
stockage <- c(18)
maj <- c(19,20)

# Trouver la liste qui contient le plus d'éléments pour après définir le nombre de colonnes de notre matrice
max_length <- max(length(materiel), length(dys_divers), length(stockage), length(maj))

# Initialiser la matrice avec des zéros
matrice_cat <- matrix(0, nrow = 4, ncol = max_length)

# Remplir les lignes de la matrice avec les listes
matrice_cat[1, 1:length(stockage)] <- stockage
matrice_cat[2, 1:length(materiel)] <- materiel
matrice_cat[3, 1:length(maj)] <- maj
matrice_cat[4, 1:length(dys_divers)] <- dys_divers

# Afficher la matrice
print(matrice_cat)
```


```{r include=FALSE}
matrice=matrix(0,nrow=5,ncol=4)

for(i in 1:nrow(data)){
  for (j in 81:105){
    val=data[i,j]
    if (!is.na(val) && !is.null(val)){
      num_pb=j-80
      result <- which(matrice_cat == num_pb, arr.ind = TRUE)
      cat <- result[1]
      matrice[val,cat]=matrice[val,cat]+1
    }
  }
}

print(matrice)
print(sum(matrice)) # 802
```

```{r include=FALSE}
resolution_label=c("Oui et le problème est resolu",
"Oui mais le problème na pas pu être résolu","Non, le problème s’est résolu tout seul au bout d’un moment","Non, peut être plus tard","Non, je ne pense pas tenter de résoudre le problème")

Catégorie = factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Catégorie = Catégorie, valeurs = matrice[1,], Légende = factor("Oui et le problème est resolu",levels=resolution_label))
df_T2 <- data.frame(Catégorie = Catégorie, valeurs = matrice[2,], Légende = factor("Oui mais le problème na pas pu être résolu",levels=resolution_label))
df_T3 <- data.frame(Catégorie = Catégorie, valeurs = matrice[3,], Légende = factor("Non, le problème s’est résolu tout seul au bout d’un moment",levels=resolution_label))
df_T4 <- data.frame(Catégorie = Catégorie, valeurs = matrice[4,], Légende = factor("Non, peut être plus tard",levels=resolution_label))
df_T5 <- data.frame(Catégorie = Catégorie, valeurs = matrice[5,], Légende = factor("Non, je ne pense pas tenter de résoudre le problème",levels=resolution_label))

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2,df_T3,df_T4,df_T5)

# Créer un diagramme en barres empilées
p5 <- ggplot(df_combined, aes(x = Catégorie, y = valeurs, fill = Légende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" si on veut des barres côtes à côtes
  labs(title = "Résolution en fonction de la catégorisation",
       x = "Catégorie",
       y = "Nombre de dysfonctionnements") +
  scale_fill_manual(values = c("Oui et le problème est resolu"="#33a02c",
"Oui mais le problème na pas pu être résolu"="#FFD700","Non, le problème s’est résolu tout seul au bout d’un moment"="gray","Non, peut être plus tard"="#fdb462","Non, je ne pense pas tenter de résoudre le problème"="#e31a1c")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.title.y = element_text(face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) 

p5_interactif <- ggplotly(p5)

# Afficher le graphique interactif
p5_interactif 
```

```{r include=FALSE}
normalize <- function(x) {
  return(round(x*100/colSums(matrice),1))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat <- t(apply(matrice, 1, normalize))
print(normalized_mat)
```


```{r include=FALSE}
resolution_label=c("Oui et le problème est resolu",
"Oui mais le problème na pas pu être résolu","Non, le problème s’est résolu tout seul au bout d’un moment","Non, peut être plus tard","Non, je ne pense pas tenter de résoudre le problème")

Catégorie = factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[1,], Légende = factor("Oui et le problème est resolu",levels=resolution_label))
df_T2 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[2,], Légende = factor("Oui mais le problème na pas pu être résolu",levels=resolution_label))
df_T3 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[3,], Légende = factor("Non, le problème s’est résolu tout seul au bout d’un moment",levels=resolution_label))
df_T4 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[4,], Légende = factor("Non, peut être plus tard",levels=resolution_label))
df_T5 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[5,], Légende = factor("Non, je ne pense pas tenter de résoudre le problème",levels=resolution_label))

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2,df_T3,df_T4,df_T5)

# Créer un diagramme en barres empilées
p6 <- ggplot(df_combined, aes(x = Catégorie, y = valeurs, fill = Légende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" so on veut des barres côtes à côtes
  labs(title = "Résolution en fonction de la catégorisation",
       x = "Catégorie",
       y = "Pourcentage de dysfonctionnements") +
  scale_fill_manual(values = c("Oui et le problème est resolu"="#33a02c",
"Oui mais le problème na pas pu être résolu"="#FFD700","Non, le problème s’est résolu tout seul au bout d’un moment"="gray","Non, peut être plus tard"="#fdb462","Non, je ne pense pas tenter de résoudre le problème"="#e31a1c")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"),  
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.y = element_text(face = "bold"),legend.position="none") 

p6_interactif <- ggplotly(p6)

# Afficher le graphique interactif
p6_interactif 
```

```{r echo=FALSE}
# Utiliser subplot pour afficher les graphiques côte à côte
library(plotly)

subplot(
  p5_interactif, p6_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)  # Ajuster les largeurs pour plus d'espace
) %>%
  layout(
    title = list(
      text = "Résolution en fonction de la catégorisation",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")  # Taille augmentée pour le titre principal
    ),
    annotations = list(
      list(
        x = 0.2, y = 1.05, text = "Sur 802 dysfonctionnements", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "black", family = "Arial", face = "bold")  # Correction pour la police en gras
      ),
      list(
        x = 0.8, y = 1.05, text = "Sur le même niveau", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "black", family = "Arial", face = "bold")  # Correction pour la police en gras
      )
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace pour les titres
    xaxis = list(domain = c(0, 0.45)),  # Ajuster la position du premier graphique
    xaxis2 = list(domain = c(0.55, 1))  # Ajuster la position du deuxième graphique
  )


```

Catégorisation + degré de gêne 

```{r include=FALSE}
matrice=matrix(0,nrow=4,ncol=4)

for(i in 1:nrow(data)){
  for (j in 31:55){
    val=data[i,j]
    if (!is.na(val) && !is.null(val)){
      num_pb=j-30
      result <- which(matrice_cat == num_pb, arr.ind = TRUE)
      cat <- result[1]
      matrice[val,cat]=matrice[val,cat]+1
    }
  }
}

print(matrice)
print(sum(matrice)) # 825

normalize <- function(x) {
  return(round(x*100/colSums(matrice),1))
}

# Transposer le résultat pour obtenir la même structure que la matrice originale
normalized_mat <- t(apply(matrice,1, normalize))
print(normalized_mat)
```

```{r include=FALSE}
gene_levels <- c("Pas du tout gênant","Plutôt pas gênant", "Plutôt gênant", "Très gênant")

Catégorie = factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Catégorie = Catégorie, valeurs = matrice[1,], Légende = factor("Très gênant",levels=gene_levels))
df_T2 <- data.frame(Catégorie = Catégorie, valeurs = matrice[2,], Légende = factor("Plutôt gênant",levels=gene_levels))
df_T3 <- data.frame(Catégorie = Catégorie, valeurs = matrice[3,], Légende = factor("Plutôt pas gênant",levels=gene_levels))
df_T4 <- data.frame(Catégorie = Catégorie, valeurs = matrice[4,], Légende = factor("Pas du tout gênant",levels=gene_levels))

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2,df_T3,df_T4)

# Créer un diagramme en barres empilées
p7 <- ggplot(df_combined, aes(x = Catégorie, y = valeurs, fill = Légende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" si on veut des barres côtes à côtes
  labs(title = "Degrés de gêne en fonction de la catégorisation",
       x = "Catégorie",
       y = "Nombre de dysfonctionnements") +
  scale_fill_brewer(palette = "Reds", name = "Degrés de gêne") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.title.y = element_text(face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) 

p7_interactif <- ggplotly(p7)

# Afficher le graphique interactif
p7_interactif 
```

```{r include=FALSE}
gene_levels <- c("Pas du tout gênant","Plutôt pas gênant", "Plutôt gênant", "Très gênant")

Catégorie = factor(label_dys, levels = label_dys)

df_T1 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[1,], Légende = factor("Très gênant",levels=gene_levels))
df_T2 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[2,], Légende = factor("Plutôt gênant",levels=gene_levels))
df_T3 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[3,], Légende = factor("Plutôt pas gênant",levels=gene_levels))
df_T4 <- data.frame(Catégorie = Catégorie, valeurs = normalized_mat[4,], Légende = factor("Pas du tout gênant",levels=gene_levels))

# Combiner les deux data frames
df_combined <- rbind(df_T1, df_T2,df_T3,df_T4)

# Créer un diagramme en barres empilées
p8 <- ggplot(df_combined, aes(x = Catégorie, y = valeurs, fill = Légende)) +
  geom_bar(stat = "identity", position = "stack") + # mettre position = "dodge" si on veut des barres côtes à côtes
  labs(title = "Degrés de gêne en fonction de la catégorisation",
       x = "Catégorie",
       y = "Pourcentage de dysfonctionnements") +
  scale_fill_brewer(palette = "Reds", name = "Degrés de gêne") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text( face = "bold"), 
        axis.title.y = element_text(face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) 

p8_interactif <- ggplotly(p8)

# Afficher le graphique interactif
p8_interactif 
```

```{r echo=FALSE}
p7_interactif <- p7_interactif %>% layout(showlegend = FALSE)

subplot(
  p7_interactif, p8_interactif,
  nrows = 1, 
  titleX = TRUE, 
  titleY = TRUE,
  shareY = FALSE,
  widths = c(0.45, 0.45)  # Ajuster les largeurs pour plus d'espace
) %>%
  layout(
    title = list(
      text = "Degrés de gêne en fonction de la catégorisation",
      font = list(size = 20, color = "black", family = "Arial", face = "bold")  # Taille augmentée pour le titre principal
    ),
    annotations = list(
      list(
        x = 0.2, y = 1.05, text = "Sur 825 dysfonctionnements", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "black", family = "Arial", face = "bold")  # Correction pour la police en gras
      ),
      list(
        x = 0.8, y = 1.05, text = "Sur le même niveau", 
        showarrow = FALSE, xref = "paper", yref = "paper", xanchor = 'center', yanchor = 'bottom', font = list(size = 14, color = "black", family = "Arial", face = "bold")  # Correction pour la police en gras
      )
    ),
    margin = list(t = 100),  # Ajuster les marges pour plus d'espace pour les titres
    xaxis = list(domain = c(0, 0.45)),  # Ajuster la position du premier graphique
    xaxis2 = list(domain = c(0.55, 1))  # Ajuster la position du deuxième graphique
  )
```

Raisons de ne pas réparer 

```{r}
nrow(data[which(data$RRAISON_UTIL_PB_FORM=="14"),])
```


```{r include=FALSE }
indice_colonne <- which(names(data) == "GENE_PROBLEMES_A1")
print(indice_colonne) # 106

indice_colonne <- which(names(data) == "REPARATION_A1")
print(indice_colonne) # 81

indice_colonne <- which(names(data) == "GENE_PROBLEMES_A25")
print(indice_colonne) # 80

indice_colonne <- which(names(data) == "REPARATION_A25")
print(indice_colonne) #105

81-31

```
